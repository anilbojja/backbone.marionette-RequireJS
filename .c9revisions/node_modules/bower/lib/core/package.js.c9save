{"ts":1353805418886,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// ==========================================\n// BOWER: Package Object Definition\n// ==========================================\n// Copyright 2012 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n// Events:\n//  - install: fired when package installed\n//  - resolve: fired when deps resolved\n//  - error: fired on all errors\n//  - data: fired when trying to output data\n// ==========================================\n\nvar fstream    = require('fstream');\nvar mkdirp     = require('mkdirp');\nvar events     = require('events');\nvar rimraf     = require('rimraf');\nvar semver     = require('semver');\nvar async      = require('async');\nvar https      = require('https');\nvar http       = require('http');\nvar path       = require('path');\nvar url        = require('url');\nvar tmp        = require('tmp');\nvar fs         = require('fs');\nvar crypto     = require('crypto');\nvar unzip      = require('unzip');\nvar tar        = require('tar');\n\nvar config     = require('./config');\nvar source     = require('./source');\nvar template   = require('../util/template');\nvar readJSON   = require('../util/read-json');\nvar fileExists = require('../util/file-exists');\nvar isRepo     = require('../util/is-repo');\nvar spawn      = require('../util/spawn');\nvar UnitWork   = require('./unit_work');\n\nvar Package = function (name, endpoint, manager) {\n  this.dependencies = {};\n  this.json         = {};\n  this.name         = name;\n  this.manager      = manager;\n  this.unitWork     = manager ? manager.unitWork : new UnitWork;\n  this.opts         = manager ? manager.opts : {};\n\n  if (endpoint) {\n    var split;\n\n    if (/^(.*\\.git)$/.exec(endpoint)) {\n      this.gitUrl = RegExp.$1.replace(/^git\\+/, '');\n      this.tag    = false;\n\n    } else if (/^(.*\\.git)#(.*)$/.exec(endpoint)) {\n      this.tag    = RegExp.$2;\n      this.gitUrl = RegExp.$1.replace(/^git\\+/, '');\n\n    } else if (/^(?:(git):|git\\+(https?):)\\/\\/([^#]+)#?(.*)$/.exec(endpoint)) {\n      this.gitUrl = (RegExp.$1 || RegExp.$2) + '://' + RegExp.$3;\n      this.tag    = RegExp.$4;\n\n    } else if (semver.validRange(endpoint)) {\n      this.tag = endpoint;\n\n    } else if (/^[\\.\\/~]\\.?[^.]*\\.(js|css)/.test(endpoint) && fs.statSync(endpoint).isFile()) {\n      this.path      = path.resolve(endpoint);\n      this.assetType = path.extname(endpoint);\n\n    } else if (/^https?:\\/\\//.exec(endpoint)) {\n      this.assetUrl  = endpoint;\n      this.assetType = path.extname(endpoint);\n\n    } else if (fileExists.sync((split = endpoint.split('#', 2))[0]) && fs.statSync(split[0]).isDirectory()) {\n      this.path = path.resolve(split[0]);\n      this.tag  = split[1];\n\n    } else if (/^[\\.\\/~]/.test(endpoint)) {\n      this.path = path.resolve(endpoint);\n\n    } else if (endpoint.split('/').length === 2) {\n      split = endpoint.split('#', 2);\n      this.gitUrl = 'git://github.com/' + split[0] + '.git';\n      this.tag = split[1];\n    } else {\n      split = endpoint.split('#', 2);\n      this.tag = split[1];\n    }\n\n    // Guess names\n    if (!this.name) {\n      if (this.gitUrl) this.name = path.basename(endpoint).replace(/(\\.git)?(#.*)?$/, '');\n      else if (this.path) this.name = path.basename(this.path, this.assetType);\n      else if (this.assetUrl) this.name = this.name = path.basename(this.assetUrl, this.assetType);\n      else if (split) this.name = split[0];\n    }\n\n    // Store a reference to the original tag & original path\n    // This is because the tag & paths can get rewriten later\n    if (this.tag) this.originalTag = this.tag;\n    if (this.path) this.originalPath = endpoint;\n\n    // The id is an unique id that describes this package\n    this.id = crypto.createHash('md5').update(this.name + '%' + this.tag + '%' + this.gitUrl +  '%' + this.path + '%' + this.assetUrl).digest('hex');\n\n    // Generate a resource id\n    if (this.gitUrl) this.generateResourceId();\n  }\n\n  if (this.manager) {\n    this.on('data',  this.manager.emit.bind(this.manager, 'data'));\n    this.on('error', function (err, origin) {\n      this.manager.emit('error', err, origin || this);\n    }.bind(this));\n  }\n\n  // Cache a self bound function\n  this.waitUnlock = this.waitUnlock.bind(this);\n\n  this.setMaxListeners(30);   // Increase the number of listeners because a package can have more than the default 10 dependencies\n};\n\nPackage.prototype = Object.create(events.EventEmitter.prototype);\n\nPackage.prototype.constructor = Package;\n\nPackage.prototype.resolve = function () {\n  // Ensure that nobody is resolving the same dep at the same time\n  // If there is, we wait for the unlock event\n  if (this.unitWork.isLocked(this.name)) return this.unitWork.on('unlock', this.waitUnlock);\n\n  var data = this.unitWork.retrieve(this.name);\n  if (data) {\n    // Check if this exact package is the last resolved one\n    // If so, we copy the resolved result and we don't need to do anything else\n    if (data.id === this.id) {\n      this.unserialize(data);\n      this.emit('resolve');\n      return this;\n    }\n  }\n\n  // If not, we lock and resolve it\n  this.unitWork.lock(this.name, this);\n\n  if (this.assetUrl) {\n    this.download();\n  } else if (this.gitUrl) {\n    this.clone();\n  } else if (this.path) {\n    this.copy();\n  } else {\n    this.once('lookup', this.clone).lookup();\n  }\n\n  return this;\n};\n\nPackage.prototype.lookup = function () {\n  source.lookup(this.name, function (err, url) {\n    if (err) return this.emit('error', err);\n    this.lookedUp = true;\n    this.gitUrl = url;\n    this.generateResourceId();\n    this.emit('lookup');\n  }.bind(this));\n};\n\nPackage.prototype.install = function () {\n  // Only print the installing action if this package has been resolved\n  if (this.unitWork.retrieve(this.name)) {\n    template('action', { name: 'installing', shizzle: this.name + (this.version ? '#' + this.version : '') })\n      .on('data', this.emit.bind(this, 'data'));\n  }\n\n  var localPath = this.localPath;\n\n  if (path.resolve(this.path) === localPath) {\n    this.emit('install');\n    return this;\n  }\n\n  // Remove stuff from the local path (if any)\n  // Rename path to the local path\n  // Beware that if the local path exists and is a git repository, the process is aborted\n  isRepo(localPath, function (is) {\n    if (is) {\n      var err = new Error('Local path is a local repository');\n      err.details = 'To avoid loosing work, please remove ' + localPath + ' manually.';\n      return this.emit('error', err, this);\n    }\n\n    mkdirp(path.dirname(localPath), function (err) {\n      if (err) return this.emit('error', err);\n      rimraf(localPath, function (err) {\n        if (err) return this.emit('error', err);\n        return fs.rename(this.path, localPath, function (err) {\n          if (!err) return this.cleanUpLocal();\n\n          var writter = fstream.Writer({\n            type: 'Directory',\n            path: localPath\n          });\n          writter\n            .on('error', this.emit.bind(this, 'error'))\n            .on('end', rimraf.bind(this, this.path, this.cleanUpLocal.bind(this)));\n\n          fstream.Reader(this.path)\n            .on('error', this.emit.bind(this, 'error'))\n            .pipe(writter);\n        }.bind(this));\n      }.bind(this));\n    }.bind(this));\n  }.bind(this));\n\n  return this;\n};\n\nPackage.prototype.cleanUpLocal = function () {\n  this.json.name    = this.name;\n  this.json.version = this.commit ? '0.0.0' : this.version || '0.0.0';\n\n  // Detect commit and save it in the json for later use\n  if (this.commit) this.json.commit = this.commit;\n  else delete this.json.commit;\n\n  if (this.gitUrl) this.json.repository = { type: 'git', url: this.gitUrl };\n  else if (this.gitPath) this.json.repository = { type: 'local-repo', path: this.originalPath };\n  else if (this.originalPath) this.json.repository = { type: 'local', path: this.originalPath };\n  else if (this.assetUrl) this.json = this.generateAssetJSON();\n\n  var jsonStr = JSON.stringify(this.json, null, 2);\n  fs.writeFile(path.join(this.localPath, config.json), jsonStr);\n  if (this.gitUrl || this.gitPath) fs.writeFile(path.join(this.gitPath, config.json), jsonStr);\n\n  rimraf(path.join(this.localPath, '.git'), this.emit.bind(this, 'install'));\n};\n\nPackage.prototype.generateAssetJSON = function () {\n  return {\n    name: this.name,\n    main: this.assetType !== '.zip' && this.assetType !== '.tar' ? 'index' + this.assetType : '',\n    version: '0.0.0',\n    repository: { type: 'asset', url: this.assetUrl }\n  };\n};\n\nPackage.prototype.uninstall = function () {\n  template('action', { name: 'uninstalling', shizzle: this.path })\n    .on('data', this.emit.bind(this, 'data'));\n  rimraf(this.path, function (err) {\n    if (err) return this.emit('error', err);\n    this.emit('uninstall');\n  }.bind(this));\n};\n\n// Private\nPackage.prototype.loadJSON = function () {\n  if (!this.path || this.assetUrl) return this.emit('loadJSON');\n\n  var jsonFile = path.join(this.path, config.json);\n  fileExists(jsonFile, function (exists) {\n    // If the json does not exists, we attempt to at least get the version\n    if (!exists) {\n      return this.once('describeTag', function (tag) {\n        tag = semver.clean(tag);\n        if (!tag) this.version = this.tag;\n        else {\n          this.version = tag;\n          if (!this.tag) this.tag = this.version;\n        }\n\n        this.emit('loadJSON');\n      }.bind(this)).describeTag();\n    }\n\n    readJSON(jsonFile, function (err, json) {\n      if (err) return this.emit('error', err);\n\n      this.json    = json;\n      this.version = this.commit || json.commit || json.version;\n      this.commit  = this.commit || json.commit;\n      // Only overwrite the name if not already set\n      // This is because some packages have different names declared in the registry and the json\n      if (!this.name) this.name = json.name;\n\n      // Read the endpoint from the json to ensure it is set correctly\n      this.readEndpoint();\n\n      // Detect if the tag mismatches the json.version\n      // This is very often to happen because developers tag their new releases but forget to update the json accordingly\n      var cleanedTag;\n      if (this.tag && (cleanedTag = semver.clean(this.tag)) && cleanedTag !== this.version) {\n        // Only print the warning once\n        if (!this.unitWork.retrieve('mismatch#' + this.name + '_' + cleanedTag)) {\n          template('warning-mismatch', { name: this.name, json: config.json, tag: cleanedTag, version: this.version || 'N/A' })\n            .on('data', this.emit.bind(this, 'data'));\n          this.unitWork.store('mismatch#' + this.name + '_' + cleanedTag, true);\n        }\n        // Assume the tag\n        this.version = cleanedTag;\n      }\n\n      this.emit('loadJSON');\n    }.bind(this), this);\n  }.bind(this));\n};\n\nPackage.prototype.download = function () {\n  template('action', { name: 'downloading', shizzle: this.assetUrl })\n    .on('data', this.emit.bind(this, 'data'));\n\n  var src  = url.parse(this.assetUrl);\n  var req  = src.protocol === 'https:' ? https : http;\n\n  if (process.env.HTTP_PROXY) {\n    src = url.parse(process.env.HTTP_PROXY);\n    src.path = this.assetUrl;\n  }\n\n  tmp.dir({ prefix: 'bower-' + this.name + '-' }, function (err, tmpPath) {\n    var file = fs.createWriteStream(path.join((this.path = tmpPath), 'index' + this.assetType));\n\n    req.get(src, function (res) {\n      // If assetUrl results in a redirect we update the assetUrl to the redirect to url\n      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n        template('action', { name: 'redirect detected', shizzle: this.assetUrl })\n          .on('data', this.emit.bind(this, 'data'));\n        this.assetUrl = res.headers.location;\n        return this.download();\n      }\n\n      // Detect not OK status codes\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        return this.emit('error', new Error(res.statusCode + ' status code for ' + this.assetUrl));\n      }\n\n      res.on('data', function (data) {\n        file.write(data);\n      });\n\n      res.on('end', function () {\n        file.end();\n\n        var next = function () {\n          this.once('loadJSON', this.saveUnit).loadJSON();\n        }.bind(this);\n\n        if (this.assetType === '.zip' || this.assetType === '.tar') this.once('extract', next).extract();\n        else next();\n      }.bind(this));\n\n    }.bind(this)).on('error', this.emit.bind(this, 'error'));\n\n  }.bind(this));\n};\n\nPackage.prototype.extract = function () {\n  var file = path.join(this.path, 'index' + this.assetType);\n  template('action', { name: 'extracting', shizzle: file }).on('data', this.emit.bind(this, 'data'));\n\n  fs.createReadStream(file).pipe(this.assetType === '.zip' ? unzip.Extract({ path: this.path }) : tar.Extract({ path: this.path }))\n    .on('error', this.emit.bind(this, 'error'))\n    .on('end', function () {\n      // Delete zip\n      fs.unlink(file, function (err) {\n        if (err) return this.emit('error', err);\n\n        // If we extracted only a folder, move all the files within it to the original path\n        fs.readdir(this.path, function (err, files) {\n          if (err) return this.emit('error', err);\n\n          if (files.length !== 1) return this.emit('extract');\n\n          var dir = path.join(this.path, files[0]);\n          fs.stat(dir, function (err, stat) {\n            if (err) return this.emit('error', err);\n            if (!stat.isDirectory()) return this.emit('extract');\n\n            fs.readdir(dir, function (err, files) {\n              if (err) return this.emit('error', err);\n\n              async.forEachSeries(files, function (file, next) {\n                fs.rename(path.join(dir, file), path.join(this.path, file), next);\n              }.bind(this), function (err) {\n                if (err) return this.emit('error');\n\n                fs.rmdir(dir, function (err) {\n                  if (err) return this.emit('error');\n                  this.emit('extract');\n                }.bind(this));\n              }.bind(this));\n            }.bind(this));\n          }.bind(this));\n        }.bind(this));\n      }.bind(this));\n    }.bind(this));\n};\n\nPackage.prototype.copy = function () {\n  template('action', { name: 'copying', shizzle: this.path }).on('data', this.emit.bind(this, 'data'));\n\n  tmp.dir({ prefix: 'bower-' + this.name + '-' }, function (err, tmpPath) {\n    fs.stat(this.path, function (err, stats) {\n      if (err) return this.emit('error', err);\n\n      // Copy file permission for directory\n      fs.chmod(tmpPath, stats.mode, function (err) {\n        if (err) return this.emit('error', err);\n\n        if (this.assetType) {\n          return fs.readFile(this.path, function (err, data) {\n            fs.writeFile(path.join((this.path = tmpPath), 'index' + this.assetType), data, function () {\n              this.once('loadJSON', this.saveUnit).loadJSON();\n            }.bind(this));\n          }.bind(this));\n        }\n\n        this.once('loadJSON', function () {\n          if (this.gitUrl) return this.saveUnit();\n\n          // Check if the copied directory is a git repository and is a local endpoint\n          // If so, treat it like a repository.\n          fileExists(path.join(this.path, '.git'), function (exists) {\n            if (!exists) return this.saveUnit();\n\n            this.gitPath = this.path;\n            this.once('loadJSON', this.saveUnit.bind(this)).checkout();\n          }.bind(this));\n        }.bind(this));\n\n        var writter = fstream.Writer({\n          type: 'Directory',\n          path: tmpPath\n        })\n         .on('error', this.emit.bind(this, 'error'))\n         .on('end', this.loadJSON.bind(this));\n\n        fstream.Reader(this.path)\n          .on('error', this.emit.bind(this, 'error'))\n          .pipe(writter);\n\n        this.path = tmpPath;\n      }.bind(this));\n    }.bind(this));\n  }.bind(this));\n};\n\nPackage.prototype.getDeepDependencies = function (result) {\n  result = result || [];\n  for (var name in this.dependencies) {\n    result.push(this.dependencies[name]);\n    this.dependencies[name].getDeepDependencies(result);\n  }\n  return result;\n};\n\nPackage.prototype.saveUnit = function () {\n  this.unitWork.store(this.name, this.serialize(), this);\n  this.unitWork.unlock(this.name, this);\n  this.addDependencies();\n};\n\nPackage.prototype.addDependencies = function () {\n  var dependencies = this.json.dependencies || {};\n  var callbacks    = Object.keys(dependencies).map(function (name) {\n    return function (callback) {\n      var endpoint = dependencies[name];\n      this.dependencies[name] = new Package(name, endpoint, this);\n      this.dependencies[name].once('resolve', callback).resolve();\n    }.bind(this);\n  }.bind(this));\n  async.parallel(callbacks, this.emit.bind(this, 'resolve'));\n};\n\nPackage.prototype.exists = function (callback) {\n  fileExists(this.localPath, callback);\n};\n\nPackage.prototype.clone = function () {\n  template('action', { name: 'cloning', shizzle: this.gitUrl }).on('data', this.emit.bind(this, 'data'));\n  this.path = this.gitPath;\n  this.once('cache', function () {\n    this.once('loadJSON', this.copy.bind(this)).checkout();\n  }.bind(this)).cache();\n};\n\nPackage.prototype.cache = function () {\n  // If the force options is true, we need to erase from the cache\n  // Be aware that a similar package might already flushed it\n  // To prevent that we check the unit of work storage\n  if (this.opts.force && !this.unitWork.retrieve('flushed#' + this.name + '_' + this.resourceId)) {\n    rimraf(this.path, function (err) {\n      if (err) return this.emit('error', err);\n      this.unitWork.store('flushed#' + this.name + '_' + this.resourceId, true);\n      this.cache();\n    }.bind(this));\n    return this;\n  }\n\n  mkdirp(config.cache, function (err) {\n    if (err) return this.emit('error', err);\n    fileExists(this.path, function (exists) {\n      if (exists) {\n        template('action', { name: 'cached', shizzle: this.gitUrl }).on('data', this.emit.bind(this, 'data'));\n        return this.emit('cache');\n      }\n      template('action', { name: 'caching', shizzle: this.gitUrl }).on('data', this.emit.bind(this, 'data'));\n      var url = this.gitUrl;\n      if (process.env.HTTP_PROXY) {\n        url = url.replace(/^git:/, 'https:');\n      }\n\n      mkdirp(this.path, function (err) {\n        if (err) return this.emit('error', err);\n\n        var cp = spawn('git', ['clone', url, this.path], null, this);\n        cp.on('close', function () {\n          this.emit('cache');\n        }.bind(this));\n      }.bind(this));\n    }.bind(this));\n  }.bind(this));\n};\n\nPackage.prototype.checkout = function () {\n  template('action', { name: 'fetching', shizzle: this.name })\n    .on('data', this.emit.bind(this, 'data'));\n\n  this.once('versions', function (versions) {\n    if (!versions.length) {\n      this.emit('checkout');\n      this.loadJSON();\n    }\n\n    // If tag is specified, try to satisfy it\n    if (this.tag) {\n      versions = versions.filter(function (version) {\n        return semver.satisfies(version, this.tag);\n      }.bind(this));\n\n      if (!versions.length) {\n        return this.emit('error', new Error(\n          'Can\\'t find tag satisfying: ' + this.name + '#' + this.tag\n        ));\n      }\n    }\n\n    // Use latest version\n    this.tag = versions[0];\n    if (!semver.valid(this.tag)) this.commit = this.tag;  // If the version is not valid, then its a commit\n\n    if (this.tag) {\n      template('action', {\n        name: 'checking out',\n        shizzle: this.name + '#' + this.tag\n      }).on('data', this.emit.bind(this, 'data'));\n\n      // Checkout the tag\n      spawn('git', [ 'checkout', this.tag, '-f'], { cwd: this.path }, this).on('close', function () {\n        // Ensure that checkout the tag as it is, removing all untracked files\n        spawn('git', ['clean', '-f', '-d'], { cwd: this.path }, this).on('close', function () {\n          this.emit('checkout');\n          this.loadJSON();\n        }.bind(this));\n      }.bind(this));\n    }\n  }).versions();\n};\n\nPackage.prototype.describeTag = function () {\n  var cp = spawn('git', ['describe', '--always', '--tag'], { cwd: this.gitPath || this.path, ignoreCodes: [128] }, this);\n  var tag = '';\n\n  cp.stdout.setEncoding('utf8');\n  cp.stdout.on('data',  function (data) {\n    tag += data;\n  });\n\n  cp.on('close', function (code) {\n    if (code === 128) tag = 'unspecified'.grey; // Not a git repo\n    this.emit('describeTag', tag.replace(/\\n$/, ''));\n  }.bind(this));\n};\n\nPackage.prototype.versions = function () {\n  this.once('fetch', function () {\n    var cp = spawn('git', ['tag'], { cwd: this.gitPath }, this);\n\n    var versions = '';\n\n    cp.stdout.setEncoding('utf8');\n    cp.stdout.on('data',  function (data) {\n      versions += data;\n    });\n\n    cp.on('close', function () {\n      versions = versions.split('\\n');\n      versions = versions.filter(function (ver) {\n        return semver.valid(ver);\n      });\n      versions = versions.sort(function (a, b) {\n        return semver.gt(a, b) ? -1 : 1;\n      });\n\n      if (versions.length) return this.emit('versions', versions);\n\n      // If there is no versions tagged in the repo\n      // then we grab the hash of the last commit\n      versions = '';\n      cp = spawn('git', ['log', '-n', 1, '--format=%H'], { cwd: this.gitPath }, this);\n\n      cp.stdout.setEncoding('utf8');\n      cp.stdout.on('data', function (data) {\n        versions += data;\n      });\n      cp.on('close', function () {\n        versions = versions.split('\\n');\n        this.emit('versions', versions);\n      }.bind(this));\n    }.bind(this));\n  }.bind(this)).fetch();\n};\n\nPackage.prototype.fetch = function () {\n  fileExists(this.gitPath, function (exists) {\n    if (!exists) return this.emit('error', new Error('Unable to fetch package ' + this.name + ' (if the cache was deleted, run install again)'));\n\n    var cp = spawn('git', ['fetch'], { cwd: this.gitPath }, this);\n    cp.on('close', function () {\n      cp = spawn('git', ['reset', '--hard', 'HEAD'], { cwd: this.gitPath }, this);\n      cp.on('close', function () {\n        this.emit('fetch');\n      }.bind(this));\n    }.bind(this));\n  }.bind(this));\n};\n\nPackage.prototype.fetchEndpoint = function () {\n  var obj = this.readEndpoint(true);\n\n  if (obj) this.emit('fetchEndpoint', obj.endpoint, obj.type);\n  else this.emit('fetchEndpoint');\n};\n\nPackage.prototype.readEndpoint = function (replace) {\n  if (!this.json.repository) return;\n\n  if (this.json.repository.type === 'git') {\n    if (replace || !this.gitUrl) {\n      this.gitUrl = this.json.repository.url;\n      this.generateResourceId();\n    }\n    return { type: 'git', endpoint: this.gitUrl };\n  }\n  if (this.json.repository.type === 'local-repo') {\n    if (replace || !this.gitPath) {\n      this.gitPath = path.resolve(this.json.repository.path);\n    }\n    return { type: 'local', endpoint: this.path };\n  }\n  if (this.json.repository.type === 'local') {\n    if (replace || !this.path) {\n      this.path = path.resolve(this.json.repository.path);\n    }\n    return { type: 'local', endpoint: this.path };\n  }\n  if (this.json.repository.type === 'asset') {\n    if (replace || !this.assetUrl) {\n      this.assetUrl = this.json.repository.url;\n      this.assetType = path.extname(this.assetUrl);\n    }\n    return { type: 'asset', endpoint: this.assetUrl };\n  }\n};\n\nPackage.prototype.waitUnlock = function (name) {\n  if (this.name === name) {\n    this.unitWork.removeListener('unlock', this.waitUnlock);\n    this.resolve();\n  }\n};\n\nPackage.prototype.serialize = function () {\n  return {\n    id: this.id,\n    resourceId: this.resourceId,\n    path: this.path,\n    originalPath: this.originalPath,\n    tag: this.tag,\n    originalTag: this.originalTag,\n    commit: this.commit,\n    assetUrl: this.assetUrl,\n    assetType: this.assetType,\n    lookedUp: this.lookedUp,\n    json: this.json,\n    gitUrl: this.gitUrl,\n    gitPath: this.gitPath,\n    dependencies: this.dependencies\n  };\n};\n\nPackage.prototype.unserialize = function (obj) {\n  for (var key in obj) {\n    this[key] = obj[key];\n  }\n\n  this.version = this.tag;\n};\n\nPackage.prototype.generateResourceId = function () {\n  this.resourceId = crypto.createHash('md5').update(this.name + '%' + this.gitUrl).digest('hex');\n  this.gitPath = path.join(config.cache, this.name, this.resourceId);\n};\n\nPackage.prototype.__defineGetter__('localPath', function () {\n  return path.join(process.cwd(), config.directory, this.name);\n});\n\nmodule.exports = Package;\n"]],"start1":0,"start2":0,"length1":0,"length2":24291}]],"length":24291}
