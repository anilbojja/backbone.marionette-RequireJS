{"ts":1354077470905,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint plusplus: false, octal:false, strict: false */\n/*global require: false, exports: false */\n\nvar fs = require('fs'),\n    path = require('path'),\n    file, prop;\n\nfunction mkDir(dir) {\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, 0777);\n    }\n}\n\nfunction mkFullDir(dir) {\n    var parts = dir.split('/'),\n        currDir = '',\n        first = true;\n    parts.forEach(function (part) {\n        //First part may be empty string if path starts with a slash.\n        currDir += part + '/';\n        first = false;\n\n        if (part) {\n            mkDir(currDir);\n        }\n    });\n}\n\nfile = {\n    backSlashRegExp: /\\\\/g,\n    getLineSeparator: function () {\n        return '/';\n    },\n\n    exists: function (fileName) {\n        return fs.existsSync(fileName);\n    },\n\n    parent: function (fileName) {\n        var parts = fileName.split('/');\n        parts.pop();\n        return parts.join('/');\n    },\n\n    /**\n     * Gets the absolute file path as a string, normalized\n     * to using front slashes for path separators.\n     * @param {String} fileName\n     */\n    absPath: function (fileName) {\n        return path.normalize(fs.realpathSync(fileName).replace(/\\\\/g, '/'));\n    },\n\n    normalize: function (fileName) {\n        return path.normalize(fileName);\n    },\n\n    isFile: function (path) {\n        return fs.statSync(path).isFile();\n    },\n\n    isDirectory: function (path) {\n        return fs.statSync(path).isDirectory();\n    },\n\n    getFilteredFileList: function (/*String*/startDir, /*RegExp*/regExpFilters, /*boolean?*/makeUnixPaths) {\n        //summary: Recurses startDir and finds matches to the files that match regExpFilters.include\n        //and do not match regExpFilters.exclude. Or just one regexp can be passed in for regExpFilters,\n        //and it will be treated as the \"include\" case.\n        //Ignores files/directories that start with a period (.).\n        var files = [], topDir, regExpInclude, regExpExclude, dirFileArray,\n            i, stat, filePath, ok, dirFiles, fileName;\n\n        topDir = startDir;\n\n        regExpInclude = regExpFilters.include || regExpFilters;\n        regExpExclude = regExpFilters.exclude || null;\n\n        if (fs.existsSync(topDir)) {\n            dirFileArray = fs.readdirSync(topDir);\n            for (i = 0; i < dirFileArray.length; i++) {\n                fileName = dirFileArray[i];\n                filePath = path.join(topDir, fileName);\n                stat = fs.statSync(filePath);\n                if (stat.isFile()) {\n                    if (makeUnixPaths) {\n                        //Make sure we have a JS string.\n                        if (filePath.indexOf(\"/\") === -1) {\n                            filePath = filePath.replace(/\\\\/g, \"/\");\n                        }\n                    }\n\n                    ok = true;\n                    if (regExpInclude) {\n                        ok = filePath.match(regExpInclude);\n                    }\n                    if (ok && regExpExclude) {\n                        ok = !filePath.match(regExpExclude);\n                    }\n\n                    if (ok && !fileName.match(/^\\./)) {\n                        files.push(filePath);\n                    }\n                } else if (stat.isDirectory() && !fileName.match(/^\\./)) {\n                    dirFiles = this.getFilteredFileList(filePath, regExpFilters, makeUnixPaths);\n                    files.push.apply(files, dirFiles);\n                }\n            }\n        }\n\n        return files; //Array\n    },\n\n    copyDir: function (/*String*/srcDir, /*String*/destDir, /*RegExp?*/regExpFilter, /*boolean?*/onlyCopyNew) {\n        //summary: copies files from srcDir to destDir using the regExpFilter to determine if the\n        //file should be copied. Returns a list file name strings of the destinations that were copied.\n        regExpFilter = regExpFilter || /\\w/;\n\n        var fileNames = file.getFilteredFileList(srcDir, regExpFilter, true),\n        copiedFiles = [], i, srcFileName, destFileName;\n\n        for (i = 0; i < fileNames.length; i++) {\n            srcFileName = fileNames[i];\n            destFileName = srcFileName.replace(srcDir, destDir);\n\n            if (file.copyFile(srcFileName, destFileName, onlyCopyNew)) {\n                copiedFiles.push(destFileName);\n            }\n        }\n\n        return copiedFiles.length ? copiedFiles : null; //Array or null\n    },\n\n    copyFile: function (/*String*/srcFileName, /*String*/destFileName, /*boolean?*/onlyCopyNew) {\n        //summary: copies srcFileName to destFileName. If onlyCopyNew is set, it only copies the file if\n        //srcFileName is newer than destFileName. Returns a boolean indicating if the copy occurred.\n        var parentDir;\n\n        //logger.trace(\"Src filename: \" + srcFileName);\n        //logger.trace(\"Dest filename: \" + destFileName);\n\n        //If onlyCopyNew is true, then compare dates and only copy if the src is newer\n        //than dest.\n        if (onlyCopyNew) {\n            if (fs.existsSync(destFileName) && fs.statSync(destFileName).mtime.getTime() >= fs.statSync(srcFileName).mtime.getTime()) {\n                return false; //Boolean\n            }\n        }\n\n        //Make sure destination dir exists.\n        parentDir = path.dirname(destFileName);\n        if (!fs.existsSync(parentDir)) {\n            mkFullDir(parentDir);\n        }\n\n        fs.writeFileSync(destFileName, fs.readFileSync(srcFileName, 'binary'), 'binary');\n        return true; //Boolean\n    },\n\n    /**\n     * Reads a *text* file.\n     */\n    readFile: function (/*String*/path, /*String?*/encoding) {\n        if (encoding === 'utf-8') {\n            encoding = 'utf8';\n        }\n        if (!encoding) {\n            encoding = 'utf8';\n        }\n\n        return fs.readFileSync(path, encoding);\n    },\n\n    saveUtf8File: function (/*String*/fileName, /*String*/fileContents) {\n        //summary: saves a *text* file using UTF-8 encoding.\n        file.saveFile(fileName, fileContents, \"utf8\");\n    },\n\n    saveFile: function (/*String*/fileName, /*String*/fileContents, /*String?*/encoding) {\n        //summary: saves a *text* file.\n        var parentDir;\n\n        if (encoding === 'utf-8') {\n            encoding = 'utf8';\n        }\n        if (!encoding) {\n            encoding = 'utf8';\n        }\n\n        //Make sure destination directories exist.\n        parentDir = path.dirname(fileName);\n        if (!fs.existsSync(parentDir)) {\n            mkFullDir(parentDir);\n        }\n\n        fs.writeFileSync(fileName, fileContents, encoding);\n    },\n\n    deleteFile: function (/*String*/fileName) {\n        //summary: deletes a file or directory if it exists.\n        var files, i, stat;\n        if (fs.existsSync(fileName)) {\n            stat = fs.statSync(fileName);\n            if (stat.isDirectory()) {\n                files = fs.readdirSync(fileName);\n                for (i = 0; i < files.length; i++) {\n                    this.deleteFile(path.join(fileName, files[i]));\n                }\n                fs.rmdirSync(fileName);\n            } else {\n                fs.unlinkSync(fileName);\n            }\n        }\n    }\n};\n\nfor (prop in file) {\n    if (file.hasOwnProperty(prop)) {\n        exports[prop] = file[prop];\n    }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":7375}]],"length":7375}
