{"ts":1345913082230,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Backbone.Marionette v0.9.1\r\n//\r\n// Copyright (C)2012 Derick Bailey, Muted Solutions, LLC\r\n// Distributed Under MIT License\r\n//\r\n// Documentation and Full License Available at:\r\n// http://github.com/derickbailey/backbone.marionette\r\n\r\nBackbone.Marionette = (function(Backbone, _, $){\r\n  var Marionette = {};\r\n\r\n// BindTo: Event Binding\r\n// ---------------------\r\n\r\n// BindTo facilitates the binding and unbinding of events\r\n// from objects that extend `Backbone.Events`. It makes\r\n// unbinding events, even with anonymous callback functions,\r\n// easy.\r\n//\r\n// Thanks to Johnny Oshika for this code.\r\n// http://stackoverflow.com/questions/7567404/backbone-js-repopulate-or-recreate-the-view/7607853#7607853\r\n\r\nMarionette.BindTo = {\r\n\r\n  // Store the event binding in array so it can be unbound\r\n  // easily, at a later point in time.\r\n  bindTo: function (obj, eventName, callback, context) {\r\n    context = context || this;\r\n    obj.on(eventName, callback, context);\r\n\r\n    if (!this.bindings) { this.bindings = []; }\r\n\r\n    var binding = {\r\n      obj: obj,\r\n      eventName: eventName,\r\n      callback: callback,\r\n      context: context\r\n    }\r\n\r\n    this.bindings.push(binding);\r\n\r\n    return binding;\r\n  },\r\n\r\n  // Unbind from a single binding object. Binding objects are\r\n  // returned from the `bindTo` method call.\r\n  unbindFrom: function(binding){\r\n    binding.obj.off(binding.eventName, binding.callback, binding.context);\r\n    this.bindings = _.reject(this.bindings, function(bind){return bind === binding});\r\n  },\r\n\r\n  // Unbind all of the events that we have stored.\r\n  unbindAll: function () {\r\n    var that = this;\r\n\r\n    // The `unbindFrom` call removes elements from the array\r\n    // while it is being iterated, so clone it first.\r\n    var bindings = _.map(this.bindings, _.identity);\r\n    _.each(bindings, function (binding, index) {\r\n      that.unbindFrom(binding);\r\n    });\r\n  }\r\n};\r\n\r\n\r\n// Marionette.View\r\n// ---------------\r\n\r\n// The core view type that other Marionette views extend from.\r\nMarionette.View = Backbone.View.extend({\r\n  constructor: function(){\r\n    Backbone.View.prototype.constructor.apply(this, arguments);\r\n    this.bindTo(this, \"show\", this.onShowCalled, this);\r\n  },\r\n\r\n  // Get the template for this view\r\n  // instance. You can set a `template` attribute in the view\r\n  // definition or pass a `template: \"whatever\"` parameter in\r\n  // to the constructor options.\r\n  getTemplate: function(){\r\n    var template;\r\n\r\n    // Get the template from `this.options.template` or\r\n    // `this.template`. The `options` takes precedence.\r\n    if (this.options && this.options.template){\r\n      template = this.options.template;\r\n    } else {\r\n      template = this.template;\r\n    }\r\n\r\n    return template;\r\n  },\r\n\r\n  // Serialize the model or collection for the view. If a model is\r\n  // found, `.toJSON()` is called. If a collection is found, `.toJSON()`\r\n  // is also called, but is used to populate an `items` array in the\r\n  // resulting data. If both are found, defaults to the model.\r\n  // You can override the `serializeData` method in your own view\r\n  // definition, to provide custom serialization for your view's data.\r\n  serializeData: function(){\r\n    var data;\r\n\r\n    if (this.model) {\r\n      data = this.model.toJSON();\r\n    }\r\n    else if (this.collection) {\r\n      data = { items: this.collection.toJSON() };\r\n    }\r\n\r\n    data = this.mixinTemplateHelpers(data);\r\n\r\n    return data;\r\n  },\r\n\r\n  // Mix in template helper methods. Looks for a\r\n  // `templateHelpers` attribute, which can either be an\r\n  // object literal, or a function that returns an object\r\n  // literal. All methods and attributes from this object\r\n  // are copies to the object passed in.\r\n  mixinTemplateHelpers: function(target){\r\n    target = target || {};\r\n    var templateHelpers = this.templateHelpers;\r\n    if (_.isFunction(templateHelpers)){\r\n      templateHelpers = templateHelpers.call(this);\r\n    }\r\n    return _.extend(target, templateHelpers);\r\n  },\r\n\r\n  // Configure `triggers` to forward DOM events to view\r\n  // events. `triggers: {\"click .foo\": \"do:foo\"}`\r\n  configureTriggers: function(){\r\n    if (!this.triggers) { return; }\r\n\r\n    var triggers = this.triggers;\r\n    var that = this;\r\n    var triggerEvents = {};\r\n\r\n    // Allow `triggers` to be configured as a function\r\n    if (_.isFunction(triggers)){ triggers = triggers.call(this); }\r\n\r\n    // Configure the triggers, prevent default\r\n    // action and stop propagation of DOM events\r\n    _.each(triggers, function(value, key){\r\n\r\n      triggerEvents[key] = function(e){\r\n        if (e && e.preventDefault){ e.preventDefault(); }\r\n        if (e && e.stopPropagation){ e.stopPropagation(); }\r\n        that.trigger(value);\r\n      }\r\n\r\n    });\r\n\r\n    return triggerEvents;\r\n  },\r\n\r\n  // Overriding Backbone.View's delegateEvents specifically\r\n  // to handle the `triggers` configuration\r\n  delegateEvents: function(events){\r\n    events = events || this.events;\r\n    if (_.isFunction(events)){ events = events.call(this)}\r\n\r\n    var combinedEvents = {};\r\n    var triggers = this.configureTriggers();\r\n    _.extend(combinedEvents, events, triggers);\r\n\r\n    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\r\n  },\r\n\r\n  // Internal method, handles the `show` event.\r\n  onShowCalled: function(){},\r\n\r\n  // Default `close` implementation, for removing a view from the\r\n  // DOM and unbinding it. Regions will call this method\r\n  // for you. You can specify an `onClose` method in your view to\r\n  // add custom code that is called after the view is closed.\r\n  close: function(){\r\n    if (this.beforeClose) { this.beforeClose(); }\r\n\r\n    this.remove();\r\n\r\n    if (this.onClose) { this.onClose(); }\r\n    this.trigger('close');\r\n    this.unbindAll();\r\n    this.unbind();\r\n  }\r\n});\r\n\r\n// Copy the features of `BindTo`\r\n_.extend(Marionette.View.prototype, Marionette.BindTo);\r\n\r\n// Item View\r\n// ---------\r\n\r\n// A single item view implementation that contains code for rendering\r\n// with underscore.js templates, serializing the view's model or collection,\r\n// and calling several methods on extended views, such as `onRender`.\r\nMarionette.ItemView =  Marionette.View.extend({\r\n  constructor: function(){\r\n    Marionette.View.prototype.constructor.apply(this, arguments);\r\n    this.initialEvents();\r\n  },\r\n\r\n  // Configured the initial events that the item view\r\n  // binds to. Override this method to prevent the initial\r\n  // events, or to add your own initial events.\r\n  initialEvents: function(){\r\n    if (this.collection){\r\n      this.bindTo(this.collection, \"reset\", this.render, this);\r\n    }\r\n  },\r\n\r\n  // Render the view, defaulting to underscore.js templates.\r\n  // You can override this in your view definition to provide\r\n  // a very specific rendering for your view. In general, though,\r\n  // you should override the `Marionette.Renderer` object to\r\n  // change how Marionette renders views.\r\n  render: function(){\r\n    if (this.beforeRender){ this.beforeRender(); }\r\n    this.trigger(\"before:render\", this);\r\n    this.trigger(\"item:before:render\", this);\r\n\r\n    var data = this.serializeData();\r\n    var template = this.getTemplate();\r\n    var html = Marionette.Renderer.render(template, data);\r\n    this.$el.html(html);\r\n\r\n    if (this.onRender){ this.onRender(); }\r\n    this.trigger(\"render\", this);\r\n    this.trigger(\"item:rendered\", this);\r\n  },\r\n\r\n  // Override the default close event to add a few\r\n  // more events that are triggered.\r\n  close: function(){\r\n    this.trigger('item:before:close');\r\n    Marionette.View.prototype.close.apply(this, arguments);\r\n    this.trigger('item:closed');\r\n  }\r\n});\r\n\r\n// Collection View\r\n// ---------------\r\n\r\n// A view that iterates over a Backbone.Collection\r\n// and renders an individual ItemView for each model.\r\nMarionette.CollectionView = Marionette.View.extend({\r\n  constructor: function(){\r\n    Marionette.View.prototype.constructor.apply(this, arguments);\r\n    this.initChildViewStorage();\r\n    this.initialEvents();\r\n    this.onShowCallbacks = new Marionette.Callbacks();\r\n  },\r\n\r\n  // Configured the initial events that the collection view\r\n  // binds to. Override this method to prevent the initial\r\n  // events, or to add your own initial events.\r\n  initialEvents: function(){\r\n    if (this.collection){\r\n      this.bindTo(this.collection, \"add\", this.addChildView, this);\r\n      this.bindTo(this.collection, \"remove\", this.removeItemView, this);\r\n      this.bindTo(this.collection, \"reset\", this.render, this);\r\n    }\r\n  },\r\n\r\n  // Handle a child item added to the collection\r\n  addChildView: function(item, collection, options){\r\n    this.closeEmptyView();\r\n    var ItemView = this.getItemView();\r\n    return this.addItemView(item, ItemView, options.index);\r\n  },\r\n\r\n  // Override from `Marionette.View` to guarantee the `onShow` method\r\n  // of child views is called.\r\n  onShowCalled: function(){\r\n    this.onShowCallbacks.run();\r\n  },\r\n\r\n  // Internal method to trigger the before render callbacks\r\n  // and events\r\n  triggerBeforeRender: function(){\r\n    if (this.beforeRender) { this.beforeRender(); }\r\n    this.trigger(\"collection:before:render\", this);\r\n  },\r\n\r\n  // Internal method to trigger the rendered callbacks and\r\n  // events\r\n  triggerRendered: function(){\r\n    if (this.onRender) { this.onRender(); }\r\n    this.trigger(\"collection:rendered\", this);\r\n  },\r\n\r\n  // Render the collection of items. Override this method to\r\n  // provide your own implementation of a render function for\r\n  // the collection view.\r\n  render: function(){\r\n    this.triggerBeforeRender();\r\n    this.closeChildren();\r\n\r\n    if (this.collection && this.collection.length > 0) {\r\n      this.showCollection();\r\n    } else {\r\n      this.showEmptyView();\r\n    }\r\n\r\n    this.triggerRendered();\r\n  },\r\n\r\n  // Internal method to loop through each item in the\r\n  // collection view and show it\r\n  showCollection: function(){\r\n    var that = this;\r\n    var ItemView = this.getItemView();\r\n    this.collection.each(function(item, index){\r\n      that.addItemView(item, ItemView, index);\r\n    });\r\n  },\r\n\r\n  // Internal method to show an empty view in place of\r\n  // a collection of item views, when the collection is\r\n  // empty\r\n  showEmptyView: function(){\r\n    var EmptyView = this.options.emptyView || this.emptyView;\r\n    if (EmptyView){\r\n      this.showingEmptyView = true;\r\n      var model = new Backbone.Model();\r\n      this.addItemView(model, EmptyView, 0);\r\n    }\r\n  },\r\n\r\n  // Internal method to close an existing emptyView instance\r\n  // if one exists. Called when a collection view has been\r\n  // rendered empty, and then an item is added to the collection.\r\n  closeEmptyView: function(){\r\n    if (this.showingEmptyView){\r\n      this.closeChildren();\r\n      delete this.showingEmptyView;\r\n    }\r\n  },\r\n\r\n  // Retrieve the itemView type, either from `this.options.itemView`\r\n  // or from the `itemView` in the object definition. The \"options\"\r\n  // takes precedence.\r\n  getItemView: function(){\r\n    var itemView = this.options.itemView || this.itemView;\r\n\r\n    if (!itemView){\r\n      var err = new Error(\"An `itemView` must be specified\");\r\n      err.name = \"NoItemViewError\";\r\n      throw err;\r\n    }\r\n\r\n    return itemView;\r\n  },\r\n\r\n  // Render the child item's view and add it to the\r\n  // HTML for the collection view.\r\n  addItemView: function(item, ItemView, index){\r\n    var that = this;\r\n\r\n    var view = this.buildItemView(item, ItemView);\r\n\r\n    // Store the child view itself so we can properly\r\n    // remove and/or close it later\r\n    this.storeChild(view);\r\n    if (this.onItemAdded){ this.onItemAdded(view); }\r\n    this.trigger(\"item:added\", view);\r\n\r\n    // Render it and show it\r\n    var renderResult = this.renderItemView(view, index);\r\n\r\n    // call onShow for child item views\r\n    if (view.onShow){\r\n      this.onShowCallbacks.add(view.onShow, view);\r\n    }\r\n\r\n    // Forward all child item view events through the parent,\r\n    // prepending \"itemview:\" to the event name\r\n    var childBinding = this.bindTo(view, \"all\", function(){\r\n      var args = slice.call(arguments);\r\n      args[0] = \"itemview:\" + args[0];\r\n      args.splice(1, 0, view);\r\n\r\n      that.trigger.apply(that, args);\r\n    });\r\n\r\n    // Store all child event bindings so we can unbind\r\n    // them when removing / closing the child view\r\n    this.childBindings = this.childBindings || {};\r\n    this.childBindings[view.cid] = childBinding;\r\n\r\n    return renderResult;\r\n  },\r\n\r\n  // render the item view\r\n  renderItemView: function(view, index) {\r\n    view.render();\r\n    this.appendHtml(this, view, index);\r\n  },\r\n\r\n  // Build an `itemView` for every model in the collection.\r\n  buildItemView: function(item, ItemView){\r\n    var itemViewOptions = _.result(this, \"itemViewOptions\");\r\n    var options = _.extend({model: item}, itemViewOptions);\r\n    var view = new ItemView(options);\r\n    return view;\r\n  },\r\n\r\n  // Remove the child view and close it\r\n  removeItemView: function(item){\r\n    var view = this.children[item.cid];\r\n    if (view){\r\n      var childBinding = this.childBindings[view.cid];\r\n      if (childBinding) {\r\n        this.unbindFrom(childBinding);\r\n        delete this.childBindings[view.cid];\r\n      }\r\n      view.close();\r\n      delete this.children[item.cid];\r\n    }\r\n\r\n    if (this.collection.length === 0){\r\n      this.showEmptyView();\r\n    }\r\n\r\n    this.trigger(\"item:removed\", view);\r\n  },\r\n\r\n  // Append the HTML to the collection's `el`.\r\n  // Override this method to do something other\r\n  // then `.append`.\r\n  appendHtml: function(collectionView, itemView, index){\r\n    collectionView.$el.append(itemView.el);\r\n  },\r\n\r\n  // Store references to all of the child `itemView`\r\n  // instances so they can be managed and cleaned up, later.\r\n  storeChild: function(view){\r\n    this.children[view.model.cid] = view;\r\n  },\r\n\r\n  // Internal method to set up the `children` object for\r\n  // storing all of the child views\r\n  initChildViewStorage: function(){\r\n    this.children = {};\r\n  },\r\n\r\n  // Handle cleanup and other closing needs for\r\n  // the collection of views.\r\n  close: function(){\r\n    this.trigger(\"collection:before:close\");\r\n    this.closeChildren();\r\n    Marionette.View.prototype.close.apply(this, arguments);\r\n    this.trigger(\"collection:closed\");\r\n  },\r\n\r\n  // Close the child views that this collection view\r\n  // is holding on to, if any\r\n  closeChildren: function(){\r\n    var that = this;\r\n    if (this.children){\r\n      _.each(_.clone(this.children), function(childView){\r\n        that.removeItemView(childView.model);\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n\r\n// Composite View\r\n// --------------\r\n\r\n// Used for rendering a branch-leaf, hierarchical structure.\r\n// Extends directly from CollectionView and also renders an\r\n// an item view as `modelView`, for the top leaf\r\nMarionette.CompositeView = Marionette.CollectionView.extend({\r\n  constructor: function(options){\r\n    Marionette.CollectionView.apply(this, arguments);\r\n    this.itemView = this.getItemView();\r\n  },\r\n\r\n  // Configured the initial events that the composite view\r\n  // binds to. Override this method to prevent the initial\r\n  // events, or to add your own initial events.\r\n  initialEvents: function(){\r\n    if (this.collection){\r\n      this.bindTo(this.collection, \"add\", this.addChildView, this);\r\n      this.bindTo(this.collection, \"remove\", this.removeItemView, this);\r\n      this.bindTo(this.collection, \"reset\", this.renderCollection, this);\r\n    }\r\n  },\r\n\r\n  // Retrieve the `itemView` to be used when rendering each of\r\n  // the items in the collection. The default is to return\r\n  // `this.itemView` or Marionette.CompositeView if no `itemView`\r\n  // has been defined\r\n  getItemView: function(){\r\n    return this.itemView || this.constructor;\r\n  },\r\n\r\n  // Renders the model once, and the collection once. Calling\r\n  // this again will tell the model's view to re-render itself\r\n  // but the collection will not re-render.\r\n  render: function(){\r\n    var that = this;\r\n\r\n    var html = this.renderModel();\r\n    this.$el.html(html);\r\n    this.trigger(\"composite:model:rendered\");\r\n    this.trigger(\"render\");\r\n\r\n    this.renderCollection();\r\n    this.trigger(\"composite:rendered\");\r\n  },\r\n\r\n  // Render the collection for the composite view\r\n  renderCollection: function(){\r\n    Marionette.CollectionView.prototype.render.apply(this, arguments);\r\n    this.trigger(\"composite:collection:rendered\");\r\n  },\r\n\r\n  // Render an individual model, if we have one, as\r\n  // part of a composite view (branch / leaf). For example:\r\n  // a treeview.\r\n  renderModel: function(){\r\n    var data = {};\r\n    data = this.serializeData();\r\n\r\n    var template = this.getTemplate();\r\n    return Marionette.Renderer.render(template, data);\r\n  }\r\n});\r\n\r\n\r\n// Region\r\n// ------\r\n\r\n// Manage the visual regions of your composite application. See\r\n// http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/\r\nMarionette.Region = function(options){\r\n  this.options = options || {};\r\n\r\n  _.extend(this, options);\r\n\r\n  if (!this.el){\r\n    var err = new Error(\"An 'el' must be specified\");\r\n    err.name = \"NoElError\";\r\n    throw err;\r\n  }\r\n\r\n  if (this.initialize){\r\n    this.initialize.apply(this, arguments);\r\n  }\r\n};\r\n\r\n_.extend(Marionette.Region.prototype, Backbone.Events, {\r\n\r\n  // Displays a backbone view instance inside of the region.\r\n  // Handles calling the `render` method for you. Reads content\r\n  // directly from the `el` attribute. Also calls an optional\r\n  // `onShow` and `close` method on your view, just after showing\r\n  // or just before closing the view, respectively.\r\n  show: function(view){\r\n    var that = this;\r\n\r\n    this.ensureEl();\r\n    this.close();\r\n\r\n    view.render();\r\n    this.open(view);\r\n\r\n    if (view.onShow) { view.onShow(); }\r\n    view.trigger(\"show\");\r\n\r\n    if (this.onShow) { this.onShow(view); }\r\n    this.trigger(\"view:show\", view);\r\n\r\n    this.currentView = view;\r\n  },\r\n\r\n  ensureEl: function(){\r\n    if (!this.$el || this.$el.length === 0){\r\n      this.$el = this.getEl(this.el);\r\n    }\r\n  },\r\n\r\n  // Override this method to change how the region finds the\r\n  // DOM element that it manages. Return a jQuery selector object.\r\n  getEl: function(selector){\r\n    return $(selector);\r\n  },\r\n\r\n  // Override this method to change how the new view is\r\n  // appended to the `$el` that the region is managing\r\n  open: function(view){\r\n    this.$el.html(view.el);\r\n  },\r\n\r\n  // Close the current view, if there is one. If there is no\r\n  // current view, it does nothing and returns immediately.\r\n  close: function(){\r\n    var view = this.currentView;\r\n    if (!view){ return; }\r\n\r\n    if (view.close) { view.close(); }\r\n    this.trigger(\"view:closed\", view);\r\n\r\n    delete this.currentView;\r\n  },\r\n\r\n  // Attach an existing view to the region. This\r\n  // will not call `render` or `onShow` for the new view,\r\n  // and will not replace the current HTML for the `el`\r\n  // of the region.\r\n  attachView: function(view){\r\n    this.currentView = view;\r\n  }\r\n});\r\n\r\n// Copy the `extend` function used by Backbone's classes\r\nMarionette.Region.extend = Backbone.View.extend;\r\n\r\n// Copy the features of `BindTo`\r\n_.extend(Marionette.Region.prototype, Marionette.BindTo);\r\n\r\n// Layout\r\n// ------\r\n\r\n// Used for managing application layouts, nested layouts and\r\n// multiple regions within an application or sub-application.\r\n//\r\n// A specialized view type that renders an area of HTML and then\r\n// attaches `Region` instances to the specified `regions`.\r\n// Used for composite view management and sub-application areas.\r\nMarionette.Layout = Marionette.ItemView.extend({\r\n  constructor: function () {\r\n    Backbone.Marionette.ItemView.apply(this, arguments);\r\n    this.initializeRegions();\r\n  },\r\n\r\n  // Layout's render will use the existing region objects the\r\n  // first time it is called. Subsequent calls will close the\r\n  // views that the regions are showing and then reset the `el`\r\n  // for the regions to the newly rendered DOM elements.\r\n  render: function(){\r\n    var result = Marionette.ItemView.prototype.render.apply(this, arguments);\r\n\r\n    // Rewrite this function to handle re-rendering and\r\n    // re-initializing the `el` for each region\r\n    this.render = function(){\r\n      this.closeRegions();\r\n      this.reInitializeRegions();\r\n\r\n      var result = Marionette.ItemView.prototype.render.apply(this, arguments);\r\n      return result;\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n  // Handle closing regions, and then close the view itself.\r\n  close: function () {\r\n    this.closeRegions();\r\n    this.destroyRegions();\r\n    Backbone.Marionette.ItemView.prototype.close.call(this, arguments);\r\n  },\r\n\r\n  // Initialize the regions that have been defined in a\r\n  // `regions` attribute on this layout. The key of the\r\n  // hash becomes an attribute on the layout object directly.\r\n  // For example: `regions: { menu: \".menu-container\" }`\r\n  // will product a `layout.menu` object which is a region\r\n  // that controls the `.menu-container` DOM element.\r\n  initializeRegions: function () {\r\n    if (!this.regionManagers){\r\n      this.regionManagers = {};\r\n    }\r\n\r\n    var that = this;\r\n    _.each(this.regions, function (selector, name) {\r\n\r\n      var regionManager = new Backbone.Marionette.Region({\r\n        el: selector,\r\n          getEl: function(selector){\r\n            return that.$(selector);\r\n          }\r\n      });\r\n\r\n      that.regionManagers[name] = regionManager;\r\n      that[name] = regionManager;\r\n    });\r\n\r\n  },\r\n\r\n  // Re-initialize all of the regions by updating the `el` that\r\n  // they point to\r\n  reInitializeRegions: function(){\r\n    _.each(this.regionManagers, function(region){\r\n      delete region.$el;\r\n    });\r\n  },\r\n\r\n  // Close all of the regions that have been opened by\r\n  // this layout. This method is called when the layout\r\n  // itself is closed.\r\n  closeRegions: function () {\r\n    var that = this;\r\n    _.each(this.regionManagers, function (manager, name) {\r\n      manager.close();\r\n    });\r\n  },\r\n\r\n  // Destroys all of the regions by removing references\r\n  // from the Layout\r\n  destroyRegions: function(){\r\n    var that = this;\r\n    _.each(this.regionManagers, function (manager, name) {\r\n      delete that[name];\r\n    });\r\n    this.regionManagers = {};\r\n  }\r\n});\r\n\r\n\r\n// Application\r\n// -----------\r\n\r\n// Contain and manage the composite application as a whole.\r\n// Stores and starts up `Region` objects, includes an\r\n// event aggregator as `app.vent`\r\nMarionette.Application = function(options){\r\n  this.initCallbacks = new Marionette.Callbacks();\r\n  this.vent = new Marionette.EventAggregator();\r\n  _.extend(this, options);\r\n};\r\n\r\n_.extend(Marionette.Application.prototype, Backbone.Events, {\r\n  // Add an initializer that is either run at when the `start`\r\n  // method is called, or run immediately if added after `start`\r\n  // has already been called.\r\n  addInitializer: function(initializer){\r\n    this.initCallbacks.add(initializer);\r\n  },\r\n\r\n  // kick off all of the application's processes.\r\n  // initializes all of the regions that have been added\r\n  // to the app, and runs all of the initializer functions\r\n  start: function(options){\r\n    this.trigger(\"initialize:before\", options);\r\n    this.initCallbacks.run(options, this);\r\n    this.trigger(\"initialize:after\", options);\r\n\r\n    this.trigger(\"start\", options);\r\n  },\r\n\r\n  // Add regions to your app.\r\n  // Accepts a hash of named strings or Region objects\r\n  // addRegions({something: \"#someRegion\"})\r\n  // addRegions{{something: Region.extend({el: \"#someRegion\"}) });\r\n  addRegions: function(regions){\r\n    var regionValue, regionObj, region;\r\n\r\n    for(region in regions){\r\n      if (regions.hasOwnProperty(region)){\r\n        regionValue = regions[region];\r\n\r\n        if (typeof regionValue === \"string\"){\r\n          regionObj = new Marionette.Region({\r\n            el: regionValue\r\n          });\r\n        } else {\r\n          regionObj = new regionValue();\r\n        }\r\n\r\n        this[region] = regionObj;\r\n      }\r\n    }\r\n  },\r\n\r\n  // Create a module, attached to the application\r\n  module: function(){\r\n    // see the Marionette.Module object for more information\r\n    return Marionette.Module.create.apply(this, arguments);\r\n  }\r\n});\r\n\r\n// Copy the `extend` function used by Backbone's classes\r\nMarionette.Application.extend = Backbone.View.extend;\r\n\r\n// Copy the features of `BindTo`\r\n_.extend(Marionette.Application.prototype, Marionette.BindTo);\r\n\r\n// AppRouter\r\n// ---------\r\n\r\n// Reduce the boilerplate code of handling route events\r\n// and then calling a single method on another object.\r\n// Have your routers configured to call the method on\r\n// your object, directly.\r\n//\r\n// Configure an AppRouter with `appRoutes`.\r\n//\r\n// App routers can only take one `controller` object.\r\n// It is recommended that you divide your controller\r\n// objects in to smaller peices of related functionality\r\n// and have multiple routers / controllers, instead of\r\n// just one giant router and controller.\r\n//\r\n// You can also add standard routes to an AppRouter.\r\n\r\nMarionette.AppRouter = Backbone.Router.extend({\r\n\r\n  constructor: function(options){\r\n    Backbone.Router.prototype.constructor.call(this, options);\r\n\r\n    if (this.appRoutes){\r\n      var controller = this.controller;\r\n      if (options && options.controller) {\r\n        controller = options.controller;\r\n      }\r\n      this.processAppRoutes(controller, this.appRoutes);\r\n    }\r\n  },\r\n\r\n  // Internal method to process the `appRoutes` for the\r\n  // router, and turn them in to routes that trigger the\r\n  // specified method on the specified `controller`.\r\n  processAppRoutes: function(controller, appRoutes){\r\n    var method, methodName;\r\n    var route, routesLength, i;\r\n    var routes = [];\r\n    var router = this;\r\n\r\n    for(route in appRoutes){\r\n      if (appRoutes.hasOwnProperty(route)){\r\n        routes.unshift([route, appRoutes[route]]);\r\n      }\r\n    }\r\n\r\n    routesLength = routes.length;\r\n    for (i = 0; i < routesLength; i++){\r\n      route = routes[i][0];\r\n      methodName = routes[i][1];\r\n      method = controller[methodName];\r\n\r\n      if (!method){\r\n        var msg = \"Method '\" + methodName + \"' was not found on the controller\";\r\n        var err = new Error(msg);\r\n        err.name = \"NoMethodError\";\r\n        throw err;\r\n      }\r\n\r\n      method = _.bind(method, controller);\r\n      router.route(route, methodName, method);\r\n    }\r\n  }\r\n});\r\n\r\n\r\n// Module\r\n// ------\r\n\r\n// A simple module system, used to create privacy and encapsulation in\r\n// Marionette applications\r\nMarionette.Module = function(){};\r\n\r\n// Extend the Module prototype with events / bindTo, so that the module\r\n// can be used as an event aggregator or pub/sub.\r\n_.extend(Marionette.Module.prototype, Backbone.Events, Marionette.BindTo);\r\n\r\n// Function level methods to create modules\r\n_.extend(Marionette.Module, {\r\n\r\n  // Create a module, hanging off 'this' as the parent object. This\r\n  // method must be called with .apply or .create\r\n  create: function(moduleNames, moduleDefinition){\r\n    var moduleName, module, moduleOverride;\r\n    var parentObject = this;\r\n    var parentModule = this;\r\n    var moduleNames = moduleNames.split(\".\");\r\n\r\n    // Loop through all the parts of the module definition\r\n    var length = moduleNames.length;\r\n    for(var i = 0; i < length; i++){\r\n      var isLastModuleInChain = (i === length-1);\r\n\r\n      // Get the module name, and check if it exists on\r\n      // the current parent already\r\n      moduleName = moduleNames[i];\r\n      module = parentModule[moduleName];\r\n\r\n      // Create a new module if we don't have one already\r\n      if (!module){\r\n        module = new Marionette.Module();\r\n      }\r\n\r\n      // Check to see if we need to run the definition\r\n      // for the module. Only run the definition if one\r\n      // is supplied, and if we're at the last segment\r\n      // of the \"Module.Name\" chain.\r\n      if (isLastModuleInChain && moduleDefinition){\r\n        // get the custom args passed in after the module definition and\r\n        // get rid of the module name and definition function\r\n        var customArgs = slice.apply(arguments);\r\n        customArgs.shift();\r\n        customArgs.shift();\r\n\r\n        // final arguments list for the module definition\r\n        var argsArray = [module, parentObject, Backbone, Marionette, jQuery, _, customArgs];\r\n\r\n        // flatten the nested array\r\n        var args = _.flatten(argsArray);\r\n\r\n        // ensure the module definition's `this` is the module itself\r\n        moduleDefinition.apply(module, args);\r\n      }\r\n\r\n      // If the defined module is not what we are\r\n      // currently storing as the module, replace it\r\n      if (parentModule[moduleName] !== module){\r\n        parentModule[moduleName] = module;\r\n      }\r\n\r\n      // Reset the parent module so that the next child\r\n      // in the list will be added to the correct parent\r\n      parentModule = module;\r\n    }\r\n\r\n    // Return the last module in the definition chain\r\n    return module;\r\n  }\r\n});\r\n\r\n// Template Cache\r\n// --------------\r\n\r\n// Manage templates stored in `<script>` blocks,\r\n// caching them for faster access.\r\nMarionette.TemplateCache = function(templateId){\r\n  this.templateId = templateId;\r\n};\r\n\r\n// TemplateCache object-level methods. Manage the template\r\n// caches from these method calls instead of creating\r\n// your own TemplateCache instances\r\n_.extend(Marionette.TemplateCache, {\r\n  templateCaches: {},\r\n\r\n  // Get the specified template by id. Either\r\n  // retrieves the cached version, or loads it\r\n  // from the DOM.\r\n  get: function(templateId){\r\n    var that = this;\r\n    var cachedTemplate = this.templateCaches[templateId];\r\n\r\n    if (!cachedTemplate){\r\n      cachedTemplate = new Marionette.TemplateCache(templateId);\r\n      this.templateCaches[templateId] = cachedTemplate;\r\n    }\r\n\r\n    return cachedTemplate.load();\r\n  },\r\n\r\n  // Clear templates from the cache. If no arguments\r\n  // are specified, clears all templates:\r\n  // `clear()`\r\n  //\r\n  // If arguments are specified, clears each of the\r\n  // specified templates from the cache:\r\n  // `clear(\"#t1\", \"#t2\", \"...\")`\r\n  clear: function(){\r\n    var i;\r\n    var length = arguments.length;\r\n\r\n    if (length > 0){\r\n      for(i=0; i<length; i++){\r\n        delete this.templateCaches[arguments[i]];\r\n      }\r\n    } else {\r\n      this.templateCaches = {};\r\n    }\r\n  }\r\n});\r\n\r\n// TemplateCache instance methods, allowing each\r\n// template cache object to manage it's own state\r\n// and know whether or not it has been loaded\r\n_.extend(Marionette.TemplateCache.prototype, {\r\n\r\n  // Internal method to load the template asynchronously.\r\n  load: function(){\r\n    var that = this;\r\n\r\n    // Guard clause to prevent loading this template more than once\r\n    if (this.compiledTemplate){\r\n      return this.compiledTemplate;\r\n    }\r\n\r\n    // Load the template and compile it\r\n    var template = this.loadTemplate(this.templateId);\r\n    this.compiledTemplate = this.compileTemplate(template);\r\n\r\n    return this.compiledTemplate;\r\n  },\r\n\r\n  // Load a template from the DOM, by default. Override\r\n  // this method to provide your own template retrieval,\r\n  // such as asynchronous loading from a server.\r\n  loadTemplate: function(templateId){\r\n    var template = $(templateId).html();\r\n\r\n    if (!template || template.length === 0){\r\n      var msg = \"Could not find template: '\" + templateId + \"'\";\r\n      var err = new Error(msg);\r\n      err.name = \"NoTemplateError\";\r\n      throw err;\r\n    }\r\n\r\n    return template;\r\n  },\r\n\r\n  // Pre-compile the template before caching it. Override\r\n  // this method if you do not need to pre-compile a template\r\n  // (JST / RequireJS for example) or if you want to change\r\n  // the template engine used (Handebars, etc).\r\n  compileTemplate: function(rawTemplate){\r\n    return _.template(rawTemplate);\r\n  }\r\n});\r\n\r\n\r\n// Renderer\r\n// --------\r\n\r\n// Render a template with data by passing in the template\r\n// selector and the data to render.\r\nMarionette.Renderer = {\r\n\r\n  // Render a template with data. The `template` parameter is\r\n  // passed to the `TemplateCache` object to retrieve the\r\n  // template function. Override this method to provide your own\r\n  // custom rendering and template handling for all of Marionette.\r\n  render: function(template, data){\r\n    var templateFunc = Marionette.TemplateCache.get(template);\r\n    var html = templateFunc(data);\r\n    return html;\r\n  }\r\n};\r\n\r\n\r\n// Callbacks\r\n// ---------\r\n\r\n// A simple way of managing a collection of callbacks\r\n// and executing them at a later point in time, using jQuery's\r\n// `Deferred` object.\r\nMarionette.Callbacks = function(){\r\n  this.deferred = $.Deferred();\r\n  this.promise = this.deferred.promise();\r\n};\r\n\r\n_.extend(Marionette.Callbacks.prototype, {\r\n\r\n  // Add a callback to be executed. Callbacks added here are\r\n  // guaranteed to execute, even if they are added after the\r\n  // `run` method is called.\r\n  add: function(callback, contextOverride){\r\n    this.promise.done(function(context, options){\r\n      if (contextOverride){ context = contextOverride; }\r\n      callback.call(context, options);\r\n    });\r\n  },\r\n\r\n  // Run all registered callbacks with the context specified.\r\n  // Additional callbacks can be added after this has been run\r\n  // and they will still be executed.\r\n  run: function(options, context){\r\n    this.deferred.resolve(context, options);\r\n  }\r\n});\r\n\r\n\r\n// Event Aggregator\r\n// ----------------\r\n\r\n// A pub-sub object that can be used to decouple various parts\r\n// of an application through event-driven architecture.\r\nMarionette.EventAggregator = function(options){\r\n  _.extend(this, options);\r\n};\r\n\r\n_.extend(Marionette.EventAggregator.prototype, Backbone.Events, Marionette.BindTo, {\r\n  // Assumes the event aggregator itself is the\r\n  // object being bound to.\r\n  bindTo: function(eventName, callback, context){\r\n    return Marionette.BindTo.bindTo.call(this, this, eventName, callback, context);\r\n  }\r\n});\r\n\r\n\r\n// Helpers\r\n// -------\r\n\r\n// For slicing `arguments` in functions\r\nvar slice = Array.prototype.slice;\r\n\r\n  return Marionette;\r\n})(Backbone, _, window.jQuery || window.Zepto || window.ender);\r\n\r\n"]],"start1":0,"start2":0,"length1":0,"length2":34046}]],"length":34046}
{"contributors":[],"silentsave":false,"ts":1345913198966,"patch":[[{"diffs":[[0,"ette"],[-1," v0.9.1\r\n//\r\n// Copyright (C)2012 Derick Bailey, Muted Solutions, LLC\r\n// Distributed Under MIT License\r\n//\r\n// Documentation and Full License Available at:\r\n// http://github.com/derickbailey/backbone.marionette\r\n\r\nBackbone.Marionette = (function(Backbone, _, $){\r\n  var Marionette = {};\r\n\r\n// BindTo: Event Binding\r\n// ---------------------\r\n\r\n// BindTo facilitates the binding and unbinding of events\r\n// from objects that extend `Backbone.Events`. It makes\r\n// unbinding events, even with anonymous callback functions,\r\n// easy.\r\n//\r\n// Thanks to Johnny Oshika for this code.\r\n// http://stackoverflow.com/questions/7567404/backbone-js-repopulate-or-recreate-the-view/7607853#7607853\r\n\r\nMarionette.BindTo = {\r\n\r\n  // Store the event binding in array so it can be unbound\r\n  // easily, at a later point in time.\r\n  bindTo: function (obj, eventName, callback, context) {\r\n    context = context || this;\r\n    obj.on(eventName, callback, context);\r\n\r\n    if (!this.bindings) { this.bindings = []; }\r\n\r\n    var binding = {\r\n      obj: obj,\r\n      eventName: eventName,\r\n      callback: callback,\r\n      context: context\r\n    }\r\n\r\n    this.bindings.push(binding);\r\n\r\n    return binding;\r\n  },\r\n\r\n  // Unbind from a single binding object. Binding objects are\r\n  // returned from the `bindTo` method call.\r\n  unbindFrom: function(binding){\r\n    binding.obj.off(binding.eventName, binding.callback, binding.context);\r\n    this.bindings = _.reject(this.bindings, function(bind){return bind === binding});\r\n  },\r\n\r\n  // Unbind all of the events that we have stored.\r\n  unbindAll: function () {\r\n    var that = this;\r\n\r\n    // The `unbindFrom` call removes elements from the array\r\n    // while it is being iterated, so clone it first.\r\n    var bindings = _.map(this.bindings, _.identity);\r\n    _.each(bindings, function (binding, index) {\r\n      that.unbindFrom(binding);\r\n    });\r\n  }\r\n};\r\n\r\n\r\n// Marionette.View\r\n// ---------------\r\n\r\n// The core view type that other Marionette views extend from.\r\nMarionette.View = Backbone.View.extend({\r\n  constructor: function(){\r\n    Backbone.View.prototype.constructor.apply(this, arguments);\r\n    this.bindTo(this, \"show\", this.onShowCalled, this);\r\n  },\r\n\r\n  // Get the template for this view\r\n  // instance. You can set a `template` attribute in the view\r\n  // definition or pass a `template: \"whatever\"` parameter in\r\n  // to the constructor options.\r\n  getTemplate: function(){\r\n    var template;\r\n\r\n    // Get the template from `this.options.template` or\r\n    // `this.template`. The `options` takes precedence.\r\n    if (this.options && this.options.template){\r\n      template = this.options.template;\r\n    } else {\r\n      template = this.template;\r\n    }\r\n\r\n    return template;\r\n  },\r\n\r\n  // Serialize the model or collection for the view. If a model is\r\n  // found, `.toJSON()` is called. If a collection is found, `.toJSON()`\r\n  // is also called, but is used to populate an `items` array in the\r\n  // resulting data. If both are found, defaults to the model.\r\n  // You can override the `serializeData` method in your own view\r\n  // definition, to provide custom serialization for your view's data.\r\n  serializeData: function(){\r\n    var data;\r\n\r\n    if (this.model) {\r\n      data = this.model.toJSON();\r\n    }\r\n    else if (this.collection) {\r\n      data = { items: this.collection.toJSON() };\r\n    }\r\n\r\n    data = this.mixinTemplateHelpers(data);\r\n\r\n    return data;\r\n  },\r\n\r\n  // Mix in template helper methods. Looks for a\r\n  // `templateHelpers` attribute, which can either be an\r\n  // object literal, or a function that returns an object\r\n  // literal. All methods and attributes from this object\r\n  // are copies to the object passed in.\r\n  mixinTemplateHelpers: function(target){\r\n    target = target || {};\r\n    var templateHelpers = this.templateHelpers;\r\n    if (_.isFunction(templateHelpers)){\r\n      templateHelpers = templateHelpers.call(this);\r\n    }\r\n    return _.extend(target, templateHelpers);\r\n  },\r\n\r\n  // Configure `triggers` to forward DOM events to view\r\n  // events. `triggers: {\"click .foo\": \"do:foo\"}`\r\n  configureTriggers: function(){\r\n    if (!this.triggers) { return; }\r\n\r\n    var triggers = this.triggers;\r\n    var that = this;\r\n    var triggerEvents = {};\r\n\r\n    // Allow `triggers` to be configured as a function\r\n    if (_.isFunction(triggers)){ triggers = triggers.call(this); }\r\n\r\n    // Configure the triggers, prevent default\r\n    // action and stop propagation of DOM events\r\n    _.each(triggers, function(value, key){\r\n\r\n      triggerEvents[key] = function(e){\r\n        if (e && e.preventDefault){ e.preventDefault(); }\r\n        if (e && e.stopPropagation){ e.stopPropagation(); }\r\n        that.trigger(value);\r\n      }\r\n\r\n    });\r\n\r\n    return triggerEvents;\r\n  },\r\n\r\n  // Overriding Backbone.View's delegateEvents specifically\r\n  // to handle the `triggers` configuration\r\n  delegateEvents: function(events){\r\n    events = events || this.events;\r\n    if (_.isFunction(events)){ events = events.call(this)}\r\n\r\n    var combinedEvents = {};\r\n    var triggers = this.configureTriggers();\r\n    _.extend(combinedEvents, events, triggers);\r\n\r\n    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\r\n  },\r\n\r\n  // Internal method, handles the `show` event.\r\n  onShowCalled: function(){},\r\n\r\n  // Default `close` implementation, for removing a view from the\r\n  // DOM and unbinding it. Regions will call this method\r\n  // for you. You can specify an `onClose` method in your view to\r\n  // add custom code that is called after the view is closed.\r\n  close: function(){\r\n    if (this.beforeClose) { this.beforeClose(); }\r\n\r\n    this.remove();\r\n\r\n    if (this.onClose) { this.onClose(); }\r\n    this.trigger('close');\r\n    this.unbindAll();\r\n    this.unbind();\r\n  }\r\n});\r\n\r\n// Copy the features of `BindTo`\r\n_.extend(Marionette.View.prototype, Marionette.BindTo);\r\n\r\n// Item View\r\n// ---------\r\n\r\n// A single item view implementation that contains code for rendering\r\n// with underscore.js templates, serializing the view's model or collection,\r\n// and calling several methods on extended views, such as `onRender`.\r\nMarionette.ItemView =  Marionette.View.extend({\r\n  constructor: function(){\r\n    Marionette.View.prototype.constructor.apply(this, arguments);\r\n    this.initialEvents();\r\n  },\r\n\r\n  // Configured the initial events that the item view\r\n  // binds to. Override this method to prevent the initial\r\n  // events, or to add your own initial events.\r\n  initialEvents: function(){\r\n    if (this.collection){\r\n      this.bindTo(this.collection, \"reset\", this.render, this);\r\n    }\r\n  },\r\n\r\n  // Render the view, defaulting to underscore.js templates.\r\n  // You can override this in your view definition to provide\r\n  // a very specific rendering for your view. In general, though,\r\n  // you should override the `Marionette.Renderer` object to\r\n  // change how Marionette renders views.\r\n  render: function(){\r\n    if (this.beforeRender){ this.beforeRender(); }\r\n    this.trigger(\"before:render\", this);\r\n    this.trigger(\"item:before:render\", this);\r\n\r\n    var data = this.serializeData();\r\n    var template = this.getTemplate();\r\n    var html = Marionette.Renderer.render(template, data);\r\n    this.$el.html(html);\r\n\r\n    if (this.onRender){ this.onRender(); }\r\n    this.trigger(\"render\", this);\r\n    this.trigger(\"item:rendered\", this);\r\n  },\r\n\r\n  // Override the default close event to add a few\r\n  // more events that are triggered.\r\n  close: function(){\r\n    this.trigger('item:before:close');\r\n    Marionette.View.prototype.close.apply(this, arguments);\r\n    this.trigger('item:closed');\r\n  }\r\n});\r\n\r\n// Collection View\r\n// ---------------\r\n\r\n// A view that iterates over a Backbone.Collection\r\n// and renders an individual ItemView for each model.\r\nMarionette.CollectionView = Marionette.View.extend({\r\n  constructor: function(){\r\n    Marionette.View.prototype.constructor.apply(this, arguments);\r\n    this.initChildViewStorage();\r\n    this.initialEvents();\r\n    this.onShowCallbacks = new Marionette.Callbacks();\r\n  },\r\n\r\n  // Configured the initial events that the collection view\r\n  // binds to. Override this method to prevent the initial\r\n  // events, or to add your own initial events.\r\n  initialEvents: function(){\r\n    if (this.collection){\r\n      this.bindTo(this.collection, \"add\", this.addChildView, this);\r\n      this.bindTo(this.collection, \"remove\", this.removeItemView, this);\r\n      this.bindTo(this.collection, \"reset\", this.render, this);\r\n    }\r\n  },\r\n\r\n  // Handle a child item added to the collection\r\n  addChildView: function(item, collection, options){\r\n    this.closeEmptyView();\r\n    var ItemView = this.getItemView();\r\n    return this.addItemView(item, ItemView, options.index);\r\n  },\r\n\r\n  // Override from `Marionette.View` to guarantee the `onShow` method\r\n  // of child views is called.\r\n  onShowCalled: function(){\r\n    this.onShowCallbacks.run();\r\n  },\r\n\r\n  // Internal method to trigger the before render callbacks\r\n  // and events\r\n  triggerBeforeRender: function(){\r\n    if (this.beforeRender) { this.beforeRender(); }\r\n    this.trigger(\"collection:before:render\", this);\r\n  },\r\n\r\n  // Internal method to trigger the rendered callbacks and\r\n  // events\r\n  triggerRendered: function(){\r\n    if (this.onRender) { this.onRender(); }\r\n    this.trigger(\"collection:rendered\", this);\r\n  },\r\n\r\n  // Render the collection of items. Override this method to\r\n  // provide your own implementation of a render function for\r\n  // the collection view.\r\n  render: function(){\r\n    this.triggerBeforeRender();\r\n    this.closeChildren();\r\n\r\n    if (this.collection && this.collection.length > 0) {\r\n      this.showCollection();\r\n    } else {\r\n      this.showEmptyView();\r\n    }\r\n\r\n    this.triggerRendered();\r\n  },\r\n\r\n  // Internal method to loop through each item in the\r\n  // collection view and show it\r\n  showCollection: function(){\r\n    var that = this;\r\n    var ItemView = this.getItemView();\r\n    this.collection.each(function(item, index){\r\n      that.addItemView(item, ItemView, index);\r\n    });\r\n  },\r\n\r\n  // Internal method to show an empty view in place of\r\n  // a collection of item views, when the collection is\r\n  // empty\r\n  showEmptyView: function(){\r\n    var EmptyView = this.options.emptyView || this.emptyView;\r\n    if (EmptyView){\r\n      this.showingEmptyView = true;\r\n      var model = new Backbone.Model();\r\n      this.addItemView(model, EmptyView, 0);\r\n    }\r\n  },\r\n\r\n  // Internal method to close an existing emptyView instance\r\n  // if one exists. Called when a collection view has been\r\n  // rendered empty, and then an item is added to the collection.\r\n  closeEmptyView: function(){\r\n    if (this.showingEmptyView){\r\n      this.closeChildren();\r\n      delete this.showingEmptyView;\r\n    }\r\n  },\r\n\r\n  // Retrieve the itemView type, either from `this.options.itemView`\r\n  // or from the `itemView` in the object definition. The \"options\"\r\n  // takes precedence.\r\n  getItemView: function(){\r\n    var itemView = this.options.itemView || this.itemView;\r\n\r\n    if (!itemView){\r\n      var err = new Error(\"An `itemView` must be specified\");\r\n      err.name = \"NoItemViewError\";\r\n      throw err;\r\n    }\r\n\r\n    return itemView;\r\n  },\r\n\r\n  // Render the child item's view and add it to the\r\n  // HTML for the collection view.\r\n  addItemView: function(item, ItemView, index){\r\n    var that = this;\r\n\r\n    var view = this.buildItemView(item, ItemView);\r\n\r\n    // Store the child view itself so we can properly\r\n    // remove and/or close it later\r\n    this.storeChild(view);\r\n    if (this.onItemAdded){ this.onItemAdded(view); }\r\n    this.trigger(\"item:added\", view);\r\n\r\n    // Render it and show it\r\n    var renderResult = this.renderItemView(view, index);\r\n\r\n    // call onShow for child item views\r\n    if (view.onShow){\r\n      this.onShowCallbacks.add(view.onShow, view);\r\n    }\r\n\r\n    // Forward all child item view events through the parent,\r\n    // prepending \"itemview:\" to the event name\r\n    var childBinding = this.bindTo(view, \"all\", function(){\r\n      var args = slice.call(arguments);\r\n      args[0] = \"itemview:\" + args[0];\r\n      args.splice(1, 0, view);\r\n\r\n      that.trigger.apply(that, args);\r\n    });\r\n\r\n    // Store all child event bindings so we can unbind\r\n    // them when removing / closing the child view\r\n    this.childBindings = this.childBindings || {};\r\n    this.childBindings[view.cid] = childBinding;\r\n\r\n    return renderResult;\r\n  },\r\n\r\n  // render the item view\r\n  renderItemView: function(view, index) {\r\n    view.render();\r\n    this.appendHtml(this, view, index);\r\n  },\r\n\r\n  // Build an `itemView` for every model in the collection.\r\n  buildItemView: function(item, ItemView){\r\n    var itemViewOptions = _.result(this, \"itemViewOptions\");\r\n    var options = _.extend({model: item}, itemViewOptions);\r\n    var view = new ItemView(options);\r\n    return view;\r\n  },\r\n\r\n  // Remove the child view and close it\r\n  removeItemView: function(item){\r\n    var view = this.children[item.cid];\r\n    if (view){\r\n      var childBinding = this.childBindings[view.cid];\r\n      if (childBinding) {\r\n        this.unbindFrom(childBinding);\r\n        delete this.childBindings[view.cid];\r\n      }\r\n      view.close();\r\n      delete this.children[item.cid];\r\n    }\r\n\r\n    if (this.collection.length === 0){\r\n      this.showEmptyView();\r\n    }\r\n\r\n    this.trigger(\"item:removed\", view);\r\n  },\r\n\r\n  // Append the HTML to the collection's `el`.\r\n  // Override this method to do something other\r\n  // then `.append`.\r\n  appendHtml: function(collectionView, itemView, index){\r\n    collectionView.$el.append(itemView.el);\r\n  },\r\n\r\n  // Store references to all of the child `itemView`\r\n  // instances so they can be managed and cleaned up, later.\r\n  storeChild: function(view){\r\n    this.children[view.model.cid] = view;\r\n  },\r\n\r\n  // Internal method to set up the `children` object for\r\n  // storing all of the child views\r\n  initChildViewStorage: function(){\r\n    this.children = {};\r\n  },\r\n\r\n  // Handle cleanup and other closing needs for\r\n  // the collection of views.\r\n  close: function(){\r\n    this.trigger(\"collection:before:close\");\r\n    this.closeChildren();\r\n    Marionette.View.prototype.close.apply(this, arguments);\r\n    this.trigger(\"collection:closed\");\r\n  },\r\n\r\n  // Close the child views that this collection view\r\n  // is holding on to, if any\r\n  closeChildren: function(){\r\n    var that = this;\r\n    if (this.children){\r\n      _.each(_.clone(this.children), function(childView){\r\n        that.removeItemView(childView.model);\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n\r\n// Composite View\r\n// --------------\r\n\r\n// Used for rendering a branch-leaf, hierarchical structure.\r\n// Extends directly from CollectionView and also renders an\r\n// an item view as `modelView`, for the top leaf\r\nMarionette.CompositeView = Marionette.CollectionView.extend({\r\n  constructor: function(options){\r\n    Marionette.CollectionView.apply(this, arguments);\r\n    this.itemView = this.getItemView();\r\n  },\r\n\r\n  // Configured the initial events that the composite view\r\n  // binds to. Override this method to prevent the initial\r\n  // events, or to add your own initial events.\r\n  initialEvents: function(){\r\n    if (this.collection){\r\n      this.bindTo(this.collection, \"add\", this.addChildView, this);\r\n      this.bindTo(this.collection, \"remove\", this.removeItemView, this);\r\n      this.bindTo(this.collection, \"reset\", this.renderCollection, this);\r\n    }\r\n  },\r\n\r\n  // Retrieve the `itemView` to be used when rendering each of\r\n  // the items in the collection. The default is to return\r\n  // `this.itemView` or Marionette.CompositeView if no `itemView`\r\n  // has been defined\r\n  getItemView: function(){\r\n    return this.itemView || this.constructor;\r\n  },\r\n\r\n  // Renders the model once, and the collection once. Calling\r\n  // this again will tell the model's view to re-render itself\r\n  // but the collection will not re-render.\r\n  render: function(){\r\n    var that = this;\r\n\r\n    var html = this.renderModel();\r\n    this.$el.html(html);\r\n    this.trigger(\"composite:model:rendered\");\r\n    this.trigger(\"render\");\r\n\r\n    this.renderCollection();\r\n    this.trigger(\"composite:rendered\");\r\n  },\r\n\r\n  // Render the collection for the composite view\r\n  renderCollection: function(){\r\n    Marionette.CollectionView.prototype.render.apply(this, arguments);\r\n    this.trigger(\"composite:collection:rendered\");\r\n  },\r\n\r\n  // Render an individual model, if we have one, as\r\n  // part of a composite view (branch / leaf). For example:\r\n  // a treeview.\r\n  renderModel: function(){\r\n    var data = {};\r\n    data = this.serializeData();\r\n\r\n    var template = this.getTemplate();\r\n    return Marionette.Renderer.render(template, data);\r\n  }\r\n});\r\n\r\n\r\n// Region\r\n// ------\r\n\r\n// Manage the visual regions of your composite application. See\r\n// http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/\r\nMarionette.Region = function(options){\r\n  this.options = options || {};\r\n\r\n  _.extend(this, options);\r\n\r\n  if (!this.el){\r\n    var err = new Error(\"An 'el' must be specified\");\r\n    err.name = \"NoElError\";\r\n    throw err;\r\n  }\r\n\r\n  if (this.initialize){\r\n    this.initialize.apply(this, arguments);\r\n  }\r\n};\r\n\r\n_.extend(Marionette.Region.prototype, Backbone.Events, {\r\n\r\n  // Displays a backbone view instance inside of the region.\r\n  // Handles calling the `render` method for you. Reads content\r\n  // directly from the `el` attribute. Also calls an optional\r\n  // `onShow` and `close` method on your view, just after showing\r\n  // or just before closing the view, respectively.\r\n  show: function(view){\r\n    var that = this;\r\n\r\n    this.ensureEl();\r\n    this.close();\r\n\r\n    view.render();\r\n    this.open(view);\r\n\r\n    if (view.onShow) { view.onShow(); }\r\n    view.trigger(\"show\");\r\n\r\n    if (this.onShow) { this.onShow(view); }\r\n    this.trigger(\"view:show\", view);\r\n\r\n    this.currentView = view;\r\n  },\r\n\r\n  ensureEl: function(){\r\n    if (!this.$el || this.$el.length === 0){\r\n      this.$el = this.getEl(this.el);\r\n    }\r\n  },\r\n\r\n  // Override this method to change how the region finds the\r\n  // DOM element that it manages. Return a jQuery selector object.\r\n  getEl: function(selector){\r\n    return $(selector);\r\n  },\r\n\r\n  // Override this method to change how the new view is\r\n  // appended to the `$el` that the region is managing\r\n  open: function(view){\r\n    this.$el.html(view.el);\r\n  },\r\n\r\n  // Close the current view, if there is one. If there is no\r\n  // current view, it does nothing and returns immediately.\r\n  close: function(){\r\n    var view = this.currentView;\r\n    if (!view){ return; }\r\n\r\n    if (view.close) { view.close(); }\r\n    this.trigger(\"view:closed\", view);\r\n\r\n    delete this.currentView;\r\n  },\r\n\r\n  // Attach an existing view to the region. This\r\n  // will not call `render` or `onShow` for the new view,\r\n  // and will not replace the current HTML for the `el`\r\n  // of the region.\r\n  attachView: function(view){\r\n    this.currentView = view;\r\n  }\r\n});\r\n\r\n// Copy the `extend` function used by Backbone's classes\r\nMarionette.Region.extend = Backbone.View.extend;\r\n\r\n// Copy the features of `BindTo`\r\n_.extend(Marionette.Region.prototype, Marionette.BindTo);\r\n\r\n// Layout\r\n// ------\r\n\r\n// Used for managing application layouts, nested layouts and\r\n// multiple regions within an application or sub-application.\r\n//\r\n// A specialized view type that renders an area of HTML and then\r\n// attaches `Region` instances to the specified `regions`.\r\n// Used for composite view management and sub-application areas.\r\nMarionette.Layout = Marionette.ItemView.extend({\r\n  constructor: function () {\r\n    Backbone.Marionette.ItemView.apply(this, arguments);\r\n    this.initializeRegions();\r\n  },\r\n\r\n  // Layout's render will use the existing region objects the\r\n  // first time it is called. Subsequent calls will close the\r\n  // views that the regions are showing and then reset the `el`\r\n  // for the regions to the newly rendered DOM elements.\r\n  render: function(){\r\n    var result = Marionette.ItemView.prototype.render.apply(this, arguments);\r\n\r\n    // Rewrite this function to handle re-rendering and\r\n    // re-initializing the `el` for each region\r\n    this.render = function(){\r\n      this.closeRegions();\r\n      this.reInitializeRegions();\r\n\r\n      var result = Marionette.ItemView.prototype.render.apply(this, arguments);\r\n      return result;\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n  // Handle closing regions, and then close the view itself.\r\n  close: function () {\r\n    this.closeRegions();\r\n    this.destroyRegions();\r\n    Backbone.Marionette.ItemView.prototype.close.call(this, arguments);\r\n  },\r\n\r\n  // Initialize the regions that have been defined in a\r\n  // `regions` attribute on this layout. The key of the\r\n  // hash becomes an attribute on the layout object directly.\r\n  // For example: `regions: { menu: \".menu-container\" }`\r\n  // will product a `layout.menu` object which is a region\r\n  // that controls the `.menu-container` DOM element.\r\n  initializeRegions: function () {\r\n    if (!this.regionManagers){\r\n      this.regionManagers = {};\r\n    }\r\n\r\n    var that = this;\r\n    _.each(this.regions, function (selector, name) {\r\n\r\n      var regionManager = new Backbone.Marionette.Region({\r\n        el: selector,\r\n          getEl: function(selector){\r\n            return that.$(selector);\r\n          }\r\n      });\r\n\r\n      that.regionManagers[name] = regionManager;\r\n      that[name] = regionManager;\r\n    });\r\n\r\n  },\r\n\r\n  // Re-initialize all of the regions by updating the `el` that\r\n  // they point to\r\n  reInitializeRegions: function(){\r\n    _.each(this.regionManagers, function(region){\r\n      delete region.$el;\r\n    });\r\n  },\r\n\r\n  // Close all of the regions that have been opened by\r\n  // this layout. This method is called when the layout\r\n  // itself is closed.\r\n  closeRegions: function () {\r\n    var that = this;\r\n    _.each(this.regionManagers, function (manager, name) {\r\n      manager.close();\r\n    });\r\n  },\r\n\r\n  // Destroys all of the regions by removing references\r\n  // from the Layout\r\n  destroyRegions: function(){\r\n    var that = this;\r\n    _.each(this.regionManagers, function (manager, name) {\r\n      delete that[name];\r\n    });\r\n    this.regionManagers = {};\r\n  }\r\n});\r\n\r\n\r\n// Application\r\n// -----------\r\n\r\n// Contain and manage the composite application as a whole.\r\n// Stores and starts up `Region` objects, includes an\r\n// event aggregator as `app.vent`\r\nMarionette.Application = function(options){\r\n  this.initCallbacks = new Marionette.Callbacks();\r\n  this.vent = new Marionette.EventAggregator();\r\n  _.extend(this, options);\r\n};\r\n\r\n_.extend(Marionette.Application.prototype, Backbone.Events, {\r\n  // Add an initializer that is either run at when the `start`\r\n  // method is called, or run immediately if added after `start`\r\n  // has already been called.\r\n  addInitializer: function(initializer){\r\n    this.initCallbacks.add(initializer);\r\n  },\r\n\r\n  // kick off all of the application's processes.\r\n  // initializes all of the regions that have been added\r\n  // to the app, and runs all of the initializer functions\r\n  start: function(options){\r\n    this.trigger(\"initialize:before\", options);\r\n    this.initCallbacks.run(options, this);\r\n    this.trigger(\"initialize:after\", options);\r\n\r\n    this.trigger(\"start\", options);\r\n  },\r\n\r\n  // Add regions to your app.\r\n  // Accepts a hash of named strings or Region objects\r\n  // addRegions({something: \"#someRegion\"})\r\n  // addRegions{{something: Region.extend({el: \"#someRegion\"}) });\r\n  addRegions: function(regions){\r\n    var regionValue, regionObj, region;\r\n\r\n    for(region in regions){\r\n      if (regions.hasOwnProperty(region)){\r\n        regionValue = regions[region];\r\n\r\n        if (typeof regionValue === \"string\"){\r\n          regionObj = new Marionette.Region({\r\n            el: regionValue\r\n          });\r\n        } else {\r\n          regionObj = new regionValue();\r\n        }\r\n\r\n        this[region] = regionObj;\r\n      }\r\n    }\r\n  },\r\n\r\n  // Create a module, attached to the application\r\n  module: function(){\r\n    // see the Marionette.Module object for more information\r\n    return Marionette.Module.create.apply(this, arguments);\r\n  }\r\n});\r\n\r\n// Copy the `extend` function used by Backbone's classes\r\nMarionette.Application.extend = Backbone.View.extend;\r\n\r\n// Copy the features of `BindTo`\r\n_.extend(Marionette.Application.prototype, Marionette.BindTo);\r\n\r\n// AppRouter\r\n// ---------\r\n\r\n// Reduce the boilerplate code of handling route events\r\n// and then calling a single method on another object.\r\n// Have your routers configured to call the method on\r\n// your object, directly.\r\n//\r\n// Configure an AppRouter with `appRoutes`.\r\n//\r\n// App routers can only take one `controller` object.\r\n// It is recommended that you divide your controller\r\n// objects in to smaller peices of related functionality\r\n// and have multiple routers / controllers, instead of\r\n// just one giant router and controller.\r\n//\r\n// You can also add standard routes to an AppRouter.\r\n\r\nMarionette.AppRouter = Backbone.Router.extend({\r\n\r\n  constructor: function(options){\r\n    Backbone.Router.prototype.constructor.call(this, options);\r\n\r\n    if (this.appRoutes){\r\n      var controller = this.controller;\r\n      if (options && options.controller) {\r\n        controller = options.controller;\r\n      }\r\n      this.processAppRoutes(controller, this.appRoutes);\r\n    }\r\n  },\r\n\r\n  // Internal method to process the `appRoutes` for the\r\n  // router, and turn them in to routes that trigger the\r\n  // specified method on the specified `controller`.\r\n  processAppRoutes: function(controller, appRoutes){\r\n    var method, methodName;\r\n    var route, routesLength, i;\r\n    var routes = [];\r\n    var router = this;\r\n\r\n    for(route in appRoutes){\r\n      if (appRoutes.hasOwnProperty(route)){\r\n        routes.unshift([route, appRoutes[route]]);\r\n      }\r\n    }\r\n\r\n    routesLength = routes.length;\r\n    for (i = 0; i < routesLength; i++){\r\n      route = routes[i][0];\r\n      methodName = routes[i][1];\r\n      method = controller[methodName];\r\n\r\n      if (!method){\r\n        var msg = \"Method '\" + methodName + \"' was not found on the controller\";\r\n        var err = new Error(msg);\r\n        err.name = \"NoMethodError\";\r\n        throw err;\r\n      }\r\n\r\n      method = _.bind(method, controller);\r\n      router.route(route, methodName, method);\r\n    }\r\n  }\r\n});\r\n\r\n\r\n// Module\r\n// ------\r\n\r\n// A simple module system, used to create privacy and encapsulation in\r\n// Marionette applications\r\nMarionette.Module = function(){};\r\n\r\n// Extend the Module prototype with events / bindTo, so that the module\r\n// can be used as an event aggregator or pub/sub.\r\n_.extend(Marionette.Module.prototype, Backbone.Events, Marionette.BindTo);\r\n\r\n// Function level methods to create modules\r\n_.extend(Marionette.Module, {\r\n\r\n  // Create a module, hanging off 'this' as the parent object. This\r\n  // method must be called with .apply or .create\r\n  create: function(moduleNames, moduleDefinition){\r\n    var moduleName, module, moduleOverride;\r\n    var parentObject = this;\r\n    var parentModule = this;\r\n    var moduleNames = moduleNames.split(\".\");\r\n\r\n    // Loop through all the parts of the module definition\r\n    var length = moduleNames.length;\r\n    for(var i = 0; i < length; i++){\r\n      var isLastModuleInChain = (i === length-1);\r\n\r\n      // Get the module name, and check if it exists on\r\n      // the current parent already\r\n      moduleName = moduleNames[i];\r\n      module = parentModule[moduleName];\r\n\r\n      // Create a new module if we don't have one already\r\n      if (!module){\r\n        module = new Marionette.Module();\r\n      }\r\n\r\n      // Check to see if we need to run the definition\r\n      // for the module. Only run the definition if one\r\n      // is supplied, and if we're at the last segment\r\n      // of the \"Module.Name\" chain.\r\n      if (isLastModuleInChain && moduleDefinition){\r\n        // get the custom args passed in after the module definition and\r\n        // get rid of the module name and definition function\r\n        var customArgs = slice.apply(arguments);\r\n        customArgs.shift();\r\n        customArgs.shift();\r\n\r\n        // final arguments list for the module definition\r\n        var argsArray = [module, parentObject, Backbone, Marionette, jQuery, _, customArgs];\r\n\r\n        // flatten the nested array\r\n        var args = _.flatten(argsArray);\r\n\r\n        // ensure the module definition's `this` is the module itself\r\n        moduleDefinition.apply(module, args);\r\n      }\r\n\r\n      // If the defined module is not what we are\r\n      // currently storing as the module, replace it\r\n      if (parentModule[moduleName] !== module){\r\n        parentModule[moduleName] = module;\r\n      }\r\n\r\n      // Reset the parent module so that the next child\r\n      // in the list will be added to the correct parent\r\n      parentModule = module;\r\n    }\r\n\r\n    // Return the last module in the definition chain\r\n    return module;\r\n  }\r\n});\r\n\r\n// Template Cache\r\n// --------------\r\n\r\n// Manage templates stored in `<script>` blocks,\r\n// caching them for faster access.\r\nMarionette.TemplateCache = function(templateId){\r\n  this.templateId = templateId;\r\n};\r\n\r\n// TemplateCache object-level methods. Manage the template\r\n// caches from these method calls instead of creating\r\n// your own TemplateCache instances\r\n_.extend(Marionette.TemplateCache, {\r\n  templateCaches: {},\r\n\r\n  // Get the specified template by id. Either\r\n  // retrieves the cached version, or loads it\r\n  // from the DOM.\r\n  get: function(templateId){\r\n    var that = this;\r\n    var cachedTemplate = this.templateCaches[templateId];\r\n\r\n    if (!cachedTemplate){\r\n      cachedTemplate = new Marionette.TemplateCache(templateId);\r\n      this.templateCaches[templateId] = cachedTemplate;\r\n    }\r\n\r\n    return cachedTemplate.load();\r\n  },\r\n\r\n  // Clear templates from the cache. If no arguments\r\n  // are specified, clears all templates:\r\n  // `clear()`\r\n  //\r\n  // If arguments are specified, clears each of the\r\n  // specified templates from the cache:\r\n  // `clear(\"#t1\", \"#t2\", \"...\")`\r\n  clear: function(){\r\n    var i;\r\n    var length = arguments.length;\r\n\r\n    if (length > 0){\r\n      for(i=0; i<length; i++){\r\n        delete this.templateCaches[arguments[i]];\r\n      }\r\n    } else {\r\n      this.templateCaches = {};\r\n    }\r\n  }\r\n});\r\n\r\n// TemplateCache instance methods, allowing each\r\n// template cache object to manage it's own state\r\n// and know whether or not it has been loaded\r\n_.extend(Marionette.TemplateCache.prototype, {\r\n\r\n  // Internal method to load the template asynchronously.\r\n  load: function(){\r\n    var that = this;\r\n\r\n    // Guard clause to prevent loading this template more than once\r\n    if (this.compiledTemplate){\r\n      return this.compiledTemplate;\r\n    }\r\n\r\n    // Load the template and compile it\r\n    var template = this.loadTemplate(this.templateId);\r\n    this.compiledTemplate = this.compileTemplate(template);\r\n\r\n    return this.compiledTemplate;\r\n  },\r\n\r\n  // Load a template from the DOM, by default. Override\r\n  // this method to provide your own template retrieval,\r\n  // such as asynchronous loading from a server.\r\n  loadTemplate: function(templateId){\r\n    var template = $(templateId).html();\r\n\r\n    if (!template || template.length === 0){\r\n      var msg = \"Could not find template: '\" + templateId + \"'\";\r\n      var err = new Error(msg);\r\n      err.name = \"NoTemplateError\";\r\n      throw err;\r\n    }\r\n\r\n    return template;\r\n  },\r\n\r\n  // Pre-compile the template before caching it. Override\r\n  // this method if you do not need to pre-compile a template\r\n  // (JST / RequireJS for example) or if you want to change\r\n  // the template engine used (Handebars, etc).\r\n  compileTemplate: function(rawTemplate){\r\n    return _.template(rawTemplate);\r\n  }\r\n});\r\n\r\n\r\n// Renderer\r\n// --------\r\n\r\n// Render a template with data by passing in the template\r\n// selector and the data to render.\r\nMarionette.Renderer = {\r\n\r\n  // Render a template with data. The `template` parameter is\r\n  // passed to the `TemplateCache` object to retrieve the\r\n  // template function. Override this method to provide your own\r\n  // custom rendering and template handling for all of Marionette.\r\n  render: function(template, data){\r\n    var templateFunc = Marionette.TemplateCache.get(template);\r\n    var html = templateFunc(data);\r\n    return html;\r\n  }\r\n};\r\n\r\n\r\n// Callbacks\r\n// ---------\r\n\r\n// A simple way of managing a collection of callbacks\r\n// and executing them at a later point in time, using jQuery's\r\n// `Deferred` object.\r\nMarionette.Callbacks = function(){\r\n  this.deferred = $.Deferred();\r\n  this.promise = this.deferred.promise();\r\n};\r\n\r\n_.extend(Marionette.Callbacks.prototype, {\r\n\r\n  // Add a callback to be executed. Callbacks added here are\r\n  // guaranteed to execute, even if they are added after the\r\n  // `run` method is called.\r\n  add: function(callback, contextOverride){\r\n    this.promise.done(function(context, options){\r\n      if (contextOverride){ context = contextOverride; }\r\n      callback.call(context, options);\r\n    });\r\n  },\r\n\r\n  // Run all registered callbacks with the context specified.\r\n  // Additional callbacks can be added after this has been run\r\n  // and they will still be executed.\r\n  run: function(options, context){\r\n    this.deferred.resolve(context, options);\r\n  }\r\n});\r\n\r\n\r\n// Event Aggregator\r\n// ----------------\r\n\r\n// A pub-sub object that can be used to decouple various parts\r\n// of an application through event-driven architecture.\r\nMarionette.EventAggregator = function(options){\r\n  _.extend(this, options);\r\n};\r\n\r\n_.extend(Marionette.EventAggregator.prototype, Backbone.Events, Marionette.BindTo, {\r\n  // Assumes the event aggregator itself is the\r\n  // object being bound to.\r\n  bindTo: function(eventName, callback, context){\r\n    return Marionette.BindTo.bindTo.call(this, this, eventName, callback, context);\r\n  }\r\n});\r\n\r\n\r\n// Helpers\r\n// -------\r\n\r\n// For slicing `arguments` in functions\r\nvar slice = Array.prototype.slice;\r\n\r\n  return Marionette;\r\n})(Backbone, _, window.jQuery || window.Zepto || window.ender);\r\n\r"],[1,", v0.9.11\n// Copyright (c)2012 Derick Bailey, Muted Solutions, LLC.\n// Distributed under MIT license\n// http://github.com/derickbailey/backbone.marionette\nBackbone.Marionette = (function(Backbone, _, $){\n  var Marionette = {};\n\n// EventBinder\n// -----------\n\n// The event binder facilitates the binding and unbinding of events\n// from objects that extend `Backbone.Events`. It makes\n// unbinding events, even with anonymous callback functions,\n// easy.\n//\n// Inspired by [Johnny Oshika](http://stackoverflow.com/questions/7567404/backbone-js-repopulate-or-recreate-the-view/7607853#7607853)\n\nMarionette.EventBinder = function(){\n  this._eventBindings = [];\n};\n\n_.extend(Marionette.EventBinder.prototype, {\n  // Store the event binding in array so it can be unbound\n  // easily, at a later point in time.\n  bindTo: function (obj, eventName, callback, context) {\n    context = context || this;\n    obj.on(eventName, callback, context);\n\n    var binding = {\n      obj: obj,\n      eventName: eventName,\n      callback: callback,\n      context: context\n    };\n\n    this._eventBindings.push(binding);\n\n    return binding;\n  },\n\n  // Unbind from a single binding object. Binding objects are\n  // returned from the `bindTo` method call.\n  unbindFrom: function(binding){\n    binding.obj.off(binding.eventName, binding.callback, binding.context);\n    this._eventBindings = _.reject(this._eventBindings, function(bind){return bind === binding;});\n  },\n\n  // Unbind all of the events that we have stored.\n  unbindAll: function () {\n    var that = this;\n\n    // The `unbindFrom` call removes elements from the array\n    // while it is being iterated, so clone it first.\n    var bindings = _.map(this._eventBindings, _.identity);\n    _.each(bindings, function (binding, index) {\n      that.unbindFrom(binding);\n    });\n  }\n});\n\n// Copy the `extend` function used by Backbone's classes\nMarionette.EventBinder.extend = Backbone.View.extend;\n\n// Marionette.View\n// ---------------\n\n// The core view type that other Marionette views extend from.\nMarionette.View = Backbone.View.extend({\n  constructor: function(){\n    var eventBinder = new Marionette.EventBinder();\n    _.extend(this, eventBinder);\n\n    Backbone.View.prototype.constructor.apply(this, arguments);\n\n    this.bindTo(this, \"show\", this.onShowCalled, this);\n  },\n\n  // Get the template for this view\n  // instance. You can set a `template` attribute in the view\n  // definition or pass a `template: \"whatever\"` parameter in\n  // to the constructor options.\n  getTemplate: function(){\n    var template;\n\n    // Get the template from `this.options.template` or\n    // `this.template`. The `options` takes precedence.\n    if (this.options && this.options.template){\n      template = this.options.template;\n    } else {\n      template = this.template;\n    }\n\n    return template;\n  },\n\n  // Serialize the model or collection for the view. If a model is\n  // found, `.toJSON()` is called. If a collection is found, `.toJSON()`\n  // is also called, but is used to populate an `items` array in the\n  // resulting data. If both are found, defaults to the model.\n  // You can override the `serializeData` method in your own view\n  // definition, to provide custom serialization for your view's data.\n  serializeData: function(){\n    var data;\n\n    if (this.model) {\n      data = this.model.toJSON();\n    }\n    else if (this.collection) {\n      data = { items: this.collection.toJSON() };\n    }\n\n    data = this.mixinTemplateHelpers(data);\n\n    return data;\n  },\n\n  // Mix in template helper methods. Looks for a\n  // `templateHelpers` attribute, which can either be an\n  // object literal, or a function that returns an object\n  // literal. All methods and attributes from this object\n  // are copies to the object passed in.\n  mixinTemplateHelpers: function(target){\n    target = target || {};\n    var templateHelpers = this.templateHelpers;\n    if (_.isFunction(templateHelpers)){\n      templateHelpers = templateHelpers.call(this);\n    }\n    return _.extend(target, templateHelpers);\n  },\n\n  // Configure `triggers` to forward DOM events to view\n  // events. `triggers: {\"click .foo\": \"do:foo\"}`\n  configureTriggers: function(){\n    if (!this.triggers) { return; }\n\n    var triggers = this.triggers;\n    var that = this;\n    var triggerEvents = {};\n\n    // Allow `triggers` to be configured as a function\n    if (_.isFunction(triggers)){ triggers = triggers.call(this); }\n\n    // Configure the triggers, prevent default\n    // action and stop propagation of DOM events\n    _.each(triggers, function(value, key){\n\n      triggerEvents[key] = function(e){\n        if (e && e.preventDefault){ e.preventDefault(); }\n        if (e && e.stopPropagation){ e.stopPropagation(); }\n        that.trigger(value);\n      };\n\n    });\n\n    return triggerEvents;\n  },\n\n  // Overriding Backbone.View's delegateEvents specifically\n  // to handle the `triggers` configuration\n  delegateEvents: function(events){\n    events = events || this.events;\n    if (_.isFunction(events)){ events = events.call(this); }\n\n    var combinedEvents = {};\n    var triggers = this.configureTriggers();\n    _.extend(combinedEvents, events, triggers);\n\n    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\n  },\n\n  // Internal method, handles the `show` event.\n  onShowCalled: function(){},\n\n  // Default `close` implementation, for removing a view from the\n  // DOM and unbinding it. Regions will call this method\n  // for you. You can specify an `onClose` method in your view to\n  // add custom code that is called after the view is closed.\n  close: function(){\n    if (this.beforeClose) { this.beforeClose(); }\n\n    this.remove();\n\n    if (this.onClose) { this.onClose(); }\n    this.trigger('close');\n    this.unbindAll();\n    this.unbind();\n  },\n\n  // This method binds the elements specified in the \"ui\" hash inside the view's code with\n  // the associated jQuery selectors.\n  bindUIElements: function(){\n    if (!this.ui) { return; }\n\n    var that = this;\n\n    if (!this.uiBindings) {\n      // We want to store the ui hash in uiBindings, since afterwards the values in the ui hash\n      // will be overridden with jQuery selectors.\n      this.uiBindings = this.ui;\n    }\n\n    // refreshing the associated selectors since they should point to the newly rendered elements.\n    this.ui = {};\n    _.each(_.keys(this.uiBindings), function(key) {\n      var selector = that.uiBindings[key];\n      that.ui[key] = that.$(selector);\n    });\n  }\n\n});\n\n\n// Item View\n// ---------\n\n// A single item view implementation that contains code for rendering\n// with underscore.js templates, serializing the view's model or collection,\n// and calling several methods on extended views, such as `onRender`.\nMarionette.ItemView = Marionette.View.extend({\n  constructor: function(){\n    Marionette.View.prototype.constructor.apply(this, arguments);\n\n    if (this.initialEvents){\n      this.initialEvents();\n    }\n  },\n\n  // Render the view, defaulting to underscore.js templates.\n  // You can override this in your view definition to provide\n  // a very specific rendering for your view. In general, though,\n  // you should override the `Marionette.Renderer` object to\n  // change how Marionette renders views.\n  render: function(){\n    if (this.beforeRender){ this.beforeRender(); }\n    this.trigger(\"before:render\", this);\n    this.trigger(\"item:before:render\", this);\n\n    var data = this.serializeData();\n    var template = this.getTemplate();\n    var html = Marionette.Renderer.render(template, data);\n    this.$el.html(html);\n    this.bindUIElements();\n\n    if (this.onRender){ this.onRender(); }\n    this.trigger(\"render\", this);\n    this.trigger(\"item:rendered\", this);\n    return this;\n  },\n\n  // Override the default close event to add a few\n  // more events that are triggered.\n  close: function(){\n    this.trigger('item:before:close');\n    Marionette.View.prototype.close.apply(this, arguments);\n    this.trigger('item:closed');\n  }\n});\n\n// Collection View\n// ---------------\n\n// A view that iterates over a Backbone.Collection\n// and renders an individual ItemView for each model.\nMarionette.CollectionView = Marionette.View.extend({\n  constructor: function(){\n    Marionette.View.prototype.constructor.apply(this, arguments);\n    this.initChildViewStorage();\n    this.initialEvents();\n    this.onShowCallbacks = new Marionette.Callbacks();\n  },\n\n  // Configured the initial events that the collection view\n  // binds to. Override this method to prevent the initial\n  // events, or to add your own initial events.\n  initialEvents: function(){\n    if (this.collection){\n      this.bindTo(this.collection, \"add\", this.addChildView, this);\n      this.bindTo(this.collection, \"remove\", this.removeItemView, this);\n      this.bindTo(this.collection, \"reset\", this.render, this);\n    }\n  },\n\n  // Handle a child item added to the collection\n  addChildView: function(item, collection, options){\n    this.closeEmptyView();\n    var ItemView = this.getItemView();\n    return this.addItemView(item, ItemView, options.index);\n  },\n\n  // Override from `Marionette.View` to guarantee the `onShow` method\n  // of child views is called.\n  onShowCalled: function(){\n    this.onShowCallbacks.run();\n  },\n\n  // Internal method to trigger the before render callbacks\n  // and events\n  triggerBeforeRender: function(){\n    if (this.beforeRender) { this.beforeRender(); }\n    this.trigger(\"before:render\", this);\n    this.trigger(\"collection:before:render\", this);\n  },\n\n  // Internal method to trigger the rendered callbacks and\n  // events\n  triggerRendered: function(){\n    if (this.onRender) { this.onRender(); }\n    this.trigger(\"render\", this);\n    this.trigger(\"collection:rendered\", this);\n  },\n\n  // Render the collection of items. Override this method to\n  // provide your own implementation of a render function for\n  // the collection view.\n  render: function(){\n    this.triggerBeforeRender();\n    this.closeEmptyView();\n    this.closeChildren();\n\n    if (this.collection && this.collection.length > 0) {\n      this.showCollection();\n    } else {\n      this.showEmptyView();\n    }\n\n    this.triggerRendered();\n    return this;\n  },\n\n  // Internal method to loop through each item in the\n  // collection view and show it\n  showCollection: function(){\n    var that = this;\n    var ItemView = this.getItemView();\n    this.collection.each(function(item, index){\n      that.addItemView(item, ItemView, index);\n    });\n  },\n\n  // Internal method to show an empty view in place of\n  // a collection of item views, when the collection is\n  // empty\n  showEmptyView: function(){\n    var EmptyView = this.options.emptyView || this.emptyView;\n    if (EmptyView && !this._showingEmptyView){\n      this._showingEmptyView = true;\n      var model = new Backbone.Model();\n      this.addItemView(model, EmptyView, 0);\n    }\n  },\n\n  // Internal method to close an existing emptyView instance\n  // if one exists. Called when a collection view has been\n  // rendered empty, and then an item is added to the collection.\n  closeEmptyView: function(){\n    if (this._showingEmptyView){\n      this.closeChildren();\n      delete this._showingEmptyView;\n    }\n  },\n\n  // Retrieve the itemView type, either from `this.options.itemView`\n  // or from the `itemView` in the object definition. The \"options\"\n  // takes precedence.\n  getItemView: function(){\n    var itemView = this.options.itemView || this.itemView;\n\n    if (!itemView){\n      var err = new Error(\"An `itemView` must be specified\");\n      err.name = \"NoItemViewError\";\n      throw err;\n    }\n\n    return itemView;\n  },\n\n  // Render the child item's view and add it to the\n  // HTML for the collection view.\n  addItemView: function(item, ItemView, index){\n    var that = this;\n\n    var view = this.buildItemView(item, ItemView);\n\n    // Store the child view itself so we can properly\n    // remove and/or close it later\n    this.storeChild(view);\n    if (this.onItemAdded){ this.onItemAdded(view); }\n    this.trigger(\"item:added\", view);\n\n    // Render it and show it\n    var renderResult = this.renderItemView(view, index);\n\n    // call onShow for child item views\n    if (view.onShow){\n      this.onShowCallbacks.add(view.onShow, view);\n    }\n\n    // Forward all child item view events through the parent,\n    // prepending \"itemview:\" to the event name\n    var childBinding = this.bindTo(view, \"all\", function(){\n      var args = slice.call(arguments);\n      args[0] = \"itemview:\" + args[0];\n      args.splice(1, 0, view);\n\n      that.trigger.apply(that, args);\n    });\n\n    // Store all child event bindings so we can unbind\n    // them when removing / closing the child view\n    this.childBindings = this.childBindings || {};\n    this.childBindings[view.cid] = childBinding;\n    \n    return renderResult;\n  },\n  \n  // render the item view\n  renderItemView: function(view, index) {\n    view.render();\n    this.appendHtml(this, view, index);\n  },\n\n  // Build an `itemView` for every model in the collection.\n  buildItemView: function(item, ItemView){\n    var itemViewOptions = _.result(this, \"itemViewOptions\");\n    var options = _.extend({model: item}, itemViewOptions);\n    var view = new ItemView(options);\n    return view;\n  },\n\n  // Remove the child view and close it\n  removeItemView: function(item){\n    var view = this.children[item.cid];\n    if (view){\n      var childBinding = this.childBindings[view.cid];\n      if (childBinding) {\n        this.unbindFrom(childBinding);\n        delete this.childBindings[view.cid];\n      }\n      view.close();\n      delete this.children[item.cid];\n    }\n\n    if (!this.collection || this.collection.length === 0){\n      this.showEmptyView();\n    }\n\n    this.trigger(\"item:removed\", view);\n  },\n\n  // Append the HTML to the collection's `el`.\n  // Override this method to do something other\n  // then `.append`.\n  appendHtml: function(collectionView, itemView, index){\n    collectionView.$el.append(itemView.el);\n  },\n\n  // Store references to all of the child `itemView`\n  // instances so they can be managed and cleaned up, later.\n  storeChild: function(view){\n    this.children[view.model.cid] = view;\n  },\n\n  // Internal method to set up the `children` object for\n  // storing all of the child views\n  initChildViewStorage: function(){\n    this.children = {};\n  },\n\n  // Handle cleanup and other closing needs for\n  // the collection of views.\n  close: function(){\n    this.trigger(\"collection:before:close\");\n    this.closeChildren();\n    Marionette.View.prototype.close.apply(this, arguments);\n    this.trigger(\"collection:closed\");\n  },\n\n  // Close the child views that this collection view\n  // is holding on to, if any\n  closeChildren: function(){\n    var that = this;\n    if (this.children){\n      _.each(_.clone(this.children), function(childView){\n        that.removeItemView(childView.model);\n      });\n    }\n  }\n});\n\n\n// Composite View\n// --------------\n\n// Used for rendering a branch-leaf, hierarchical structure.\n// Extends directly from CollectionView and also renders an\n// an item view as `modelView`, for the top leaf\nMarionette.CompositeView = Marionette.CollectionView.extend({\n  constructor: function(options){\n    Marionette.CollectionView.apply(this, arguments);\n    this.itemView = this.getItemView();\n  },\n\n  // Configured the initial events that the composite view\n  // binds to. Override this method to prevent the initial\n  // events, or to add your own initial events.\n  initialEvents: function(){\n    if (this.collection){\n      this.bindTo(this.collection, \"add\", this.addChildView, this);\n      this.bindTo(this.collection, \"remove\", this.removeItemView, this);\n      this.bindTo(this.collection, \"reset\", this.renderCollection, this);\n    }\n  },\n\n  // Retrieve the `itemView` to be used when rendering each of\n  // the items in the collection. The default is to return\n  // `this.itemView` or Marionette.CompositeView if no `itemView`\n  // has been defined\n  getItemView: function(){\n    return this.itemView || this.constructor;\n  },\n\n  // Renders the model once, and the collection once. Calling\n  // this again will tell the model's view to re-render itself\n  // but the collection will not re-render.\n  render: function(){\n    var that = this;\n\n    this.resetItemViewContainer();\n\n    var html = this.renderModel();\n    this.$el.html(html);\n    // the ui bindings is done here and not at the end of render since they should be\n    // available before the collection is rendered.\n    this.bindUIElements();\n    this.trigger(\"composite:model:rendered\");\n    this.trigger(\"render\");\n\n    this.renderCollection();\n    this.trigger(\"composite:rendered\");\n    return this;\n  },\n\n  // Render the collection for the composite view\n  renderCollection: function(){\n    Marionette.CollectionView.prototype.render.apply(this, arguments);\n    this.trigger(\"composite:collection:rendered\");\n  },\n\n  // Render an individual model, if we have one, as\n  // part of a composite view (branch / leaf). For example:\n  // a treeview.\n  renderModel: function(){\n    var data = {};\n    data = this.serializeData();\n\n    var template = this.getTemplate();\n    return Marionette.Renderer.render(template, data);\n  },\n\n  // Appends the `el` of itemView instances to the specified\n  // `itemViewContainer` (a jQuery selector). Override this method to\n  // provide custom logic of how the child item view instances have their\n  // HTML appended to the composite view instance.\n  appendHtml: function(cv, iv){\n    var $container = this.getItemViewContainer(cv);\n    $container.append(iv.el);\n  },\n\n  // Internal method to ensure an `$itemViewContainer` exists, for the\n  // `appendHtml` method to use.\n  getItemViewContainer: function(containerView){\n    var container;\n    if (\"$itemViewContainer\" in containerView){\n      container = containerView.$itemViewContainer;\n    } else {\n      if (containerView.itemViewContainer){\n        container = containerView.$(_.result(containerView, \"itemViewContainer\"));\n\n        if (container.length <= 0) {\n          var err = new Error(\"Missing `itemViewContainer`\");\n          err.name = \"ItemViewContainerMissingError\";\n          throw err;\n        }\n      } else {\n        container = containerView.$el;\n      }\n      containerView.$itemViewContainer = container;\n    }\n    return container;\n  },\n\n  // Internal method to reset the `$itemViewContainer` on render\n  resetItemViewContainer: function(){\n    if (this.$itemViewContainer){\n      delete this.$itemViewContainer;\n    }\n  }\n});\n\n\n// Region\n// ------\n\n// Manage the visual regions of your composite application. See\n// http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/\nMarionette.Region = function(options){\n  this.options = options || {};\n\n  var eventBinder = new Marionette.EventBinder();\n  _.extend(this, eventBinder, options);\n\n  if (!this.el){\n    var err = new Error(\"An 'el' must be specified\");\n    err.name = \"NoElError\";\n    throw err;\n  }\n\n  if (this.initialize){\n    this.initialize.apply(this, arguments);\n  }\n};\n\n_.extend(Marionette.Region.prototype, Backbone.Events, {\n\n  // Displays a backbone view instance inside of the region.\n  // Handles calling the `render` method for you. Reads content\n  // directly from the `el` attribute. Also calls an optional\n  // `onShow` and `close` method on your view, just after showing\n  // or just before closing the view, respectively.\n  show: function(view){\n\n    this.ensureEl();\n    this.close();\n\n    view.render();\n    this.open(view);\n\n    if (view.onShow) { view.onShow(); }\n    view.trigger(\"show\");\n\n    if (this.onShow) { this.onShow(view); }\n    this.trigger(\"view:show\", view);\n\n    this.currentView = view;\n  },\n\n  ensureEl: function(){\n    if (!this.$el || this.$el.length === 0){\n      this.$el = this.getEl(this.el);\n    }\n  },\n\n  // Override this method to change how the region finds the\n  // DOM element that it manages. Return a jQuery selector object.\n  getEl: function(selector){\n    return $(selector);\n  },\n\n  // Override this method to change how the new view is\n  // appended to the `$el` that the region is managing\n  open: function(view){\n    this.$el.html(view.el);\n  },\n\n  // Close the current view, if there is one. If there is no\n  // current view, it does nothing and returns immediately.\n  close: function(){\n    var view = this.currentView;\n    if (!view){ return; }\n\n    if (view.close) { view.close(); }\n    this.trigger(\"view:closed\", view);\n\n    delete this.currentView;\n  },\n\n  // Attach an existing view to the region. This\n  // will not call `render` or `onShow` for the new view,\n  // and will not replace the current HTML for the `el`\n  // of the region.\n  attachView: function(view){\n    this.currentView = view;\n  },\n\n  // Reset the region by closing any existing view and\n  // clearing out the cached `$el`. The next time a view\n  // is shown via this region, the region will re-query the\n  // DOM for the region's `el`.\n  reset: function(){\n    this.close();\n    delete this.$el;\n  }\n});\n\n// Copy the `extend` function used by Backbone's classes\nMarionette.Region.extend = Backbone.View.extend;\n\n// Layout\n// ------\n\n// Used for managing application layouts, nested layouts and\n// multiple regions within an application or sub-application.\n//\n// A specialized view type that renders an area of HTML and then\n// attaches `Region` instances to the specified `regions`.\n// Used for composite view management and sub-application areas.\nMarionette.Layout = Marionette.ItemView.extend({\n  regionType: Marionette.Region,\n\n  constructor: function () {\n    Backbone.Marionette.ItemView.apply(this, arguments);\n    this.initializeRegions();\n  },\n\n  // Layout's render will use the existing region objects the\n  // first time it is called. Subsequent calls will close the\n  // views that the regions are showing and then reset the `el`\n  // for the regions to the newly rendered DOM elements.\n  render: function(){\n    var result = Marionette.ItemView.prototype.render.apply(this, arguments);\n\n    // Rewrite this function to handle re-rendering and\n    // re-initializing the `el` for each region\n    this.render = function(){\n      this.closeRegions();\n      this.reInitializeRegions();\n\n      var result = Marionette.ItemView.prototype.render.apply(this, arguments);\n      return result;\n    };\n\n    return result;\n  },\n\n  // Handle closing regions, and then close the view itself.\n  close: function () {\n    this.closeRegions();\n    this.destroyRegions();\n    Backbone.Marionette.ItemView.prototype.close.call(this, arguments);\n  },\n\n  // Initialize the regions that have been defined in a\n  // `regions` attribute on this layout. The key of the\n  // hash becomes an attribute on the layout object directly.\n  // For example: `regions: { menu: \".menu-container\" }`\n  // will product a `layout.menu` object which is a region\n  // that controls the `.menu-container` DOM element.\n  initializeRegions: function () {\n    if (!this.regionManagers){\n      this.regionManagers = {};\n    }\n\n    var that = this;\n    _.each(this.regions, function (region, name) {\n      if ( typeof region != 'string'\n           && typeof region.selector != 'string' ) {\n        throw new Exception('Region must be specified as a selector ' +\n                            'string or an object with selector property');\n      }\n\n      var selector = typeof region === 'string' ? region : region.selector;\n      var regionType = typeof region.regionType === 'undefined'\n        ? that.regionType : region.regionType;\n      \n      var regionManager = new regionType({\n        el: selector,\n          getEl: function(selector){\n            return that.$(selector);\n          }\n      });\n\n      that.regionManagers[name] = regionManager;\n      that[name] = regionManager;\n    });\n\n  },\n\n  // Re-initialize all of the regions by updating the `el` that\n  // they point to\n  reInitializeRegions: function(){\n    if (this.regionManagers && _.size(this.regionManagers)===0){\n      this.initializeRegions();\n    } else {\n      _.each(this.regionManagers, function(region){\n        region.reset();\n      });\n    }\n  },\n\n  // Close all of the regions that have been opened by\n  // this layout. This method is called when the layout\n  // itself is closed.\n  closeRegions: function () {\n    var that = this;\n    _.each(this.regionManagers, function (manager, name) {\n      manager.close();\n    });\n  },\n\n  // Destroys all of the regions by removing references\n  // from the Layout\n  destroyRegions: function(){\n    var that = this;\n    _.each(this.regionManagers, function (manager, name) {\n      delete that[name];\n    });\n    this.regionManagers = {};\n  }\n});\n\n\n// Application\n// -----------\n\n// Contain and manage the composite application as a whole.\n// Stores and starts up `Region` objects, includes an\n// event aggregator as `app.vent`\nMarionette.Application = function(options){\n  this.initCallbacks = new Marionette.Callbacks();\n  this.vent = new Marionette.EventAggregator();\n  this.submodules = {};\n\n  var eventBinder = new Marionette.EventBinder();\n  _.extend(this, eventBinder, options);\n};\n\n_.extend(Marionette.Application.prototype, Backbone.Events, {\n  // Add an initializer that is either run at when the `start`\n  // method is called, or run immediately if added after `start`\n  // has already been called.\n  addInitializer: function(initializer){\n    this.initCallbacks.add(initializer);\n  },\n\n  // kick off all of the application's processes.\n  // initializes all of the regions that have been added\n  // to the app, and runs all of the initializer functions\n  start: function(options){\n    this.trigger(\"initialize:before\", options);\n    this.initCallbacks.run(options, this);\n    this.trigger(\"initialize:after\", options);\n\n    this.trigger(\"start\", options);\n  },\n\n  // Add regions to your app.\n  // Accepts a hash of named strings or Region objects\n  // addRegions({something: \"#someRegion\"})\n  // addRegions{{something: Region.extend({el: \"#someRegion\"}) });\n  addRegions: function(regions){\n    var regionValue, regionObj, region;\n\n    for(region in regions){\n      if (regions.hasOwnProperty(region)){\n        regionValue = regions[region];\n\n        if (typeof regionValue === \"string\"){\n          regionObj = new Marionette.Region({\n            el: regionValue\n          });\n        } else {\n          regionObj = new regionValue();\n        }\n\n        this[region] = regionObj;\n      }\n    }\n  },\n\n  // Removes a region from your app.\n  // Accepts the regions name\n  // removeRegion('myRegion')\n  removeRegion: function(region) {\n    this[region].close();\n    delete this[region];\n  },\n\n  // Create a module, attached to the application\n  module: function(moduleNames, moduleDefinition){\n    // slice the args, and add this application object as the\n    // first argument of the array\n    var args = slice.call(arguments);\n    args.unshift(this);\n\n    // see the Marionette.Module object for more information\n    return Marionette.Module.create.apply(Marionette.Module, args);\n  }\n});\n\n// Copy the `extend` function used by Backbone's classes\nMarionette.Application.extend = Backbone.View.extend;\n\n// AppRouter\n// ---------\n\n// Reduce the boilerplate code of handling route events\n// and then calling a single method on another object.\n// Have your routers configured to call the method on\n// your object, directly.\n//\n// Configure an AppRouter with `appRoutes`.\n//\n// App routers can only take one `controller` object.\n// It is recommended that you divide your controller\n// objects in to smaller peices of related functionality\n// and have multiple routers / controllers, instead of\n// just one giant router and controller.\n//\n// You can also add standard routes to an AppRouter.\n\nMarionette.AppRouter = Backbone.Router.extend({\n\n  constructor: function(options){\n    Backbone.Router.prototype.constructor.call(this, options);\n\n    if (this.appRoutes){\n      var controller = this.controller;\n      if (options && options.controller) {\n        controller = options.controller;\n      }\n      this.processAppRoutes(controller, this.appRoutes);\n    }\n  },\n\n  // Internal method to process the `appRoutes` for the\n  // router, and turn them in to routes that trigger the\n  // specified method on the specified `controller`.\n  processAppRoutes: function(controller, appRoutes){\n    var method, methodName;\n    var route, routesLength, i;\n    var routes = [];\n    var router = this;\n\n    for(route in appRoutes){\n      if (appRoutes.hasOwnProperty(route)){\n        routes.unshift([route, appRoutes[route]]);\n      }\n    }\n\n    routesLength = routes.length;\n    for (i = 0; i < routesLength; i++){\n      route = routes[i][0];\n      methodName = routes[i][1];\n      method = controller[methodName];\n\n      if (!method){\n        var msg = \"Method '\" + methodName + \"' was not found on the controller\";\n        var err = new Error(msg);\n        err.name = \"NoMethodError\";\n        throw err;\n      }\n\n      method = _.bind(method, controller);\n      router.route(route, methodName, method);\n    }\n  }\n});\n\n\n// Module\n// ------\n\n// A simple module system, used to create privacy and encapsulation in\n// Marionette applications\nMarionette.Module = function(moduleName, app, customArgs){\n  this.moduleName = moduleName;\n\n  // store sub-modules\n  this.submodules = {};\n\n  this._setupInitializersAndFinalizers();\n\n  // store the configuration for this module\n  this._config = {};\n  this._config.app = app;\n  this._config.customArgs = customArgs;\n  this._config.definitions = [];\n\n  // extend this module with an event binder\n  var eventBinder = new Marionette.EventBinder();\n  _.extend(this, eventBinder);\n};\n\n// Extend the Module prototype with events / bindTo, so that the module\n// can be used as an event aggregator or pub/sub.\n_.extend(Marionette.Module.prototype, Backbone.Events, {\n\n  // Initializer for a specific module. Initializers are run when the\n  // module's `start` method is called.\n  addInitializer: function(callback){\n    this._initializerCallbacks.add(callback);\n  },\n\n  // Finalizers are run when a module is stopped. They are used to teardown\n  // and finalize any variables, references, events and other code that the\n  // module had set up.\n  addFinalizer: function(callback){\n    this._finalizerCallbacks.add(callback);\n  },\n\n  // Start the module, and run all of it's initializers\n  start: function(options){\n    // Prevent re-start the module\n    if (this._isInitialized){ return; }\n\n    this._runModuleDefinition();\n    this._initializerCallbacks.run(options, this);\n    this._isInitialized = true;\n\n    // start the sub-modules\n    if (this.submodules){\n      _.each(this.submodules, function(mod){\n        mod.start(options);\n      });\n    }\n  },\n\n  // Stop this module by running its finalizers and then stop all of\n  // the sub-modules for this module\n  stop: function(){\n    // if we are not initialized, don't bother finalizing\n    if (!this._isInitialized){ return; }\n    this._isInitialized = false;\n\n    // run the finalizers\n    this._finalizerCallbacks.run();\n    // then reset the initializers and finalizers\n    this._setupInitializersAndFinalizers();\n\n    // stop the sub-modules\n    _.each(this.submodules, function(mod){ mod.stop(); });\n  },\n\n  // Configure the module with a definition function and any custom args\n  // that are to be passed in to the definition function\n  addDefinition: function(moduleDefinition){\n    this._config.definitions.push(moduleDefinition);\n  },\n\n  // Internal method: run the module definition function with the correct\n  // arguments\n  _runModuleDefinition: function(){\n    if (this._config.definitions.length === 0) { return; }\n\n    // build the correct list of arguments for the module definition\n    var args = _.flatten([\n      this,\n      this._config.app,\n      Backbone,\n      Marionette,\n      $, _,\n      this._config.customArgs\n    ]);\n\n    // run the module definition function with the correct args\n    var definitionCount = this._config.definitions.length-1;\n    for(var i=0; i <= definitionCount; i++){\n\n      var definition = this._config.definitions[i];\n      definition.apply(this, args);\n\n    }\n  },\n\n  // Internal method: set up new copies of initializers and finalizers.\n  // Calling this method will wipe out all existing initializers and\n  // finalizers.\n  _setupInitializersAndFinalizers: function(){\n    this._initializerCallbacks = new Marionette.Callbacks();\n    this._finalizerCallbacks = new Marionette.Callbacks();\n  }\n});\n\n// Function level methods to create modules\n_.extend(Marionette.Module, {\n\n  // Create a module, hanging off the app parameter as the parent object.\n  create: function(app, moduleNames, moduleDefinition){\n    var that = this;\n    var parentModule = app;\n    moduleNames = moduleNames.split(\".\");\n\n    // get the custom args passed in after the module definition and\n    // get rid of the module name and definition function\n    var customArgs = slice.apply(arguments);\n    customArgs.splice(0, 3);\n\n    // Loop through all the parts of the module definition\n    var length = moduleNames.length;\n    _.each(moduleNames, function(moduleName, i){\n      var isLastModuleInChain = (i === length-1);\n\n      // Get an existing module of this name if we have one\n      var module = parentModule[moduleName];\n      if (!module){\n        // Create a new module if we don't have one\n        module = new Marionette.Module(moduleName, app, customArgs);\n        parentModule[moduleName] = module;\n        // store the module on the parent\n        parentModule.submodules[moduleName] = module;\n      }\n\n      // Only add a module definition and initializer when this is\n      // the last module in a \"parent.child.grandchild\" hierarchy of\n      // module names\n      if (isLastModuleInChain ){\n        that._createModuleDefinition(module, moduleDefinition, app);\n      }\n\n      // Reset the parent module so that the next child\n      // in the list will be added to the correct parent\n      parentModule = module;\n    });\n\n    // Return the last module in the definition chain\n    return parentModule;\n  },\n\n  _createModuleDefinition: function(module, moduleDefinition, app){\n    var moduleOptions = this._getModuleDefinitionOptions(moduleDefinition);\n    \n    // add the module definition\n    if (moduleOptions.definition){\n      module.addDefinition(moduleOptions.definition);\n    }\n\n    if (moduleOptions.startWithApp){\n      // start the module when the app starts\n      app.addInitializer(function(options){\n        module.start(options);\n      });\n    }\n  },\n\n  _getModuleDefinitionOptions: function(moduleDefinition){\n    // default to starting the module with the app\n    var options = { startWithApp: true };\n\n    // short circuit if we don't have a module definition\n    if (!moduleDefinition){ return options; }\n\n    if (_.isFunction(moduleDefinition)){\n      // if the definition is a function, assign it directly\n      // and use the defaults\n      options.definition = moduleDefinition;\n\n    } else {\n\n      // the definition is an object. grab the \"define\" attribute\n      // and the \"startWithApp\" attribute, as set the options\n      // appropriately\n      options.definition = moduleDefinition.define;\n      if (moduleDefinition.hasOwnProperty(\"startWithApp\")){\n        options.startWithApp = moduleDefinition.startWithApp;\n      }\n    }\n\n    return options;\n  }\n});\n\n// Template Cache\n// --------------\n\n// Manage templates stored in `<script>` blocks,\n// caching them for faster access.\nMarionette.TemplateCache = function(templateId){\n  this.templateId = templateId;\n};\n\n// TemplateCache object-level methods. Manage the template\n// caches from these method calls instead of creating\n// your own TemplateCache instances\n_.extend(Marionette.TemplateCache, {\n  templateCaches: {},\n\n  // Get the specified template by id. Either\n  // retrieves the cached version, or loads it\n  // from the DOM.\n  get: function(templateId){\n    var that = this;\n    var cachedTemplate = this.templateCaches[templateId];\n\n    if (!cachedTemplate){\n      cachedTemplate = new Marionette.TemplateCache(templateId);\n      this.templateCaches[templateId] = cachedTemplate;\n    }\n\n    return cachedTemplate.load();\n  },\n\n  // Clear templates from the cache. If no arguments\n  // are specified, clears all templates:\n  // `clear()`\n  //\n  // If arguments are specified, clears each of the\n  // specified templates from the cache:\n  // `clear(\"#t1\", \"#t2\", \"...\")`\n  clear: function(){\n    var i;\n    var length = arguments.length;\n\n    if (length > 0){\n      for(i=0; i<length; i++){\n        delete this.templateCaches[arguments[i]];\n      }\n    } else {\n      this.templateCaches = {};\n    }\n  }\n});\n\n// TemplateCache instance methods, allowing each\n// template cache object to manage it's own state\n// and know whether or not it has been loaded\n_.extend(Marionette.TemplateCache.prototype, {\n\n  // Internal method to load the template asynchronously.\n  load: function(){\n    var that = this;\n\n    // Guard clause to prevent loading this template more than once\n    if (this.compiledTemplate){\n      return this.compiledTemplate;\n    }\n\n    // Load the template and compile it\n    var template = this.loadTemplate(this.templateId);\n    this.compiledTemplate = this.compileTemplate(template);\n\n    return this.compiledTemplate;\n  },\n\n  // Load a template from the DOM, by default. Override\n  // this method to provide your own template retrieval,\n  // such as asynchronous loading from a server.\n  loadTemplate: function(templateId){\n    var template = $(templateId).html();\n\n    if (!template || template.length === 0){\n      var msg = \"Could not find template: '\" + templateId + \"'\";\n      var err = new Error(msg);\n      err.name = \"NoTemplateError\";\n      throw err;\n    }\n\n    return template;\n  },\n\n  // Pre-compile the template before caching it. Override\n  // this method if you do not need to pre-compile a template\n  // (JST / RequireJS for example) or if you want to change\n  // the template engine used (Handebars, etc).\n  compileTemplate: function(rawTemplate){\n    return _.template(rawTemplate);\n  }\n});\n\n\n// Renderer\n// --------\n\n// Render a template with data by passing in the template\n// selector and the data to render.\nMarionette.Renderer = {\n\n  // Render a template with data. The `template` parameter is\n  // passed to the `TemplateCache` object to retrieve the\n  // template function. Override this method to provide your own\n  // custom rendering and template handling for all of Marionette.\n  render: function(template, data){\n    var templateFunc = typeof template === 'function' ? template : Marionette.TemplateCache.get(template);\n    var html = templateFunc(data);\n    return html;\n  }\n};\n\n\n// Callbacks\n// ---------\n\n// A simple way of managing a collection of callbacks\n// and executing them at a later point in time, using jQuery's\n// `Deferred` object.\nMarionette.Callbacks = function(){\n  this.deferred = $.Deferred();\n  this.promise = this.deferred.promise();\n};\n\n_.extend(Marionette.Callbacks.prototype, {\n\n  // Add a callback to be executed. Callbacks added here are\n  // guaranteed to execute, even if they are added after the\n  // `run` method is called.\n  add: function(callback, contextOverride){\n    this.promise.done(function(context, options){\n      if (contextOverride){ context = contextOverride; }\n      callback.call(context, options);\n    });\n  },\n\n  // Run all registered callbacks with the context specified.\n  // Additional callbacks can be added after this has been run\n  // and they will still be executed.\n  run: function(options, context){\n    this.deferred.resolve(context, options);\n  }\n});\n\n\n// Event Aggregator\n// ----------------\n\n// A pub-sub object that can be used to decouple various parts\n// of an application through event-driven architecture.\nMarionette.EventAggregator = Marionette.EventBinder.extend({\n  \n  // Extend any provided options directly on to the event binder\n  constructor: function(options){\n    Marionette.EventBinder.apply(this, arguments);\n    _.extend(this, options);\n  },\n\n  // Override the `bindTo` method to ensure that the event aggregator\n  // is used as the event binding storage\n  bindTo: function(eventName, callback, context){\n    return Marionette.EventBinder.prototype.bindTo.call(this, this, eventName, callback, context);\n  }\n});\n\n// Copy the basic Backbone.Events on to the event aggregator\n_.extend(Marionette.EventAggregator.prototype, Backbone.Events);\n\n// Copy the `extend` function used by Backbone's classes\nMarionette.EventAggregator.extend = Backbone.View.extend;\n\n\n// Helpers\n// -------\n\n// For slicing `arguments` in functions\nvar slice = Array.prototype.slice;\n\n\n  return Marionette;\n})(Backbone, _, window.jQuery || window.Zepto || window.ender);\n"],[0,"\n"]],"start1":18,"start2":18,"length1":34028,"length2":40582}]],"length":40600,"saved":false}
